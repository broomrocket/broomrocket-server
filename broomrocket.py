"""
Broomrocket: convert human text to Blender scenes

This module is intended to be used as a Blender addon.

SPDX-License-Identifier: MIT
"""

__copyright__ = "Copyright (c) Something Pink"
__license__ = "MIT"
__contact__ = "https://something.pink/contact/"

import abc
import dataclasses
import enum
import glob
import json
import logging
import os
import re
import tempfile
import typing
import unittest
import urllib.parse
from zipfile import ZipFile

import requests


# region Broomrocket core (common)

@dataclasses.dataclass
class License:
    """
    A license is an object describing a license that is supported by a mesh provider. You can use the license ID to
    filter meshes that comply with your license policy.
    """
    id: str
    name: str
    description: str


@dataclasses.dataclass
class Coordinate:
    """
    Coordinate is a single coordinate in a 3-dimensional space. When used as a coordinate of a mesh, changes to these
    properties must change the underlying locations in the mesh.
    """
    x: float
    y: float
    z: float

    def get_axis(self, axis: typing.ForwardRef("Axis")) -> float:
        return getattr(self, str(axis))

    def set_axis(self, axis: typing.ForwardRef("Axis"), value: float):
        setattr(self, str(axis), value)

    @classmethod
    def from_dict(cls, param):
        # TODO error handling
        return Coordinate(param["x"], param["y"], param["z"])


@dataclasses.dataclass
class Volume:
    """
    A volume is a simplified bounding box of a mesh, containing the minimum and maximum coordinates of a mesh on each
    axis.
    """
    min_x: float
    max_x: float
    min_y: float
    max_y: float
    min_z: float
    max_z: float

    def _init(
            self,
            min_x: float = 0.0,
            max_x: float = 0.0,
            min_y: float = 0.0,
            max_y: float = 0.0,
            min_z: float = 0.0,
            max_z: float = 0.0
    ):
        self.min_x = min_x
        self.max_x = max_x
        self.min_y = min_y
        self.max_y = max_y
        self.min_z = min_z
        self.max_z = max_z

    def __eq__(self, other):
        return self.min_x == other.min_x and \
            self.max_x == other.max_x and \
            self.min_y == other.min_y and \
            self.max_y == other.max_y and \
            self.min_z == other.min_z and \
            self.max_z == other.max_z

    def min_axis(self, axis: typing.ForwardRef("Axis")) -> float:
        return getattr(self, "min_" + str(axis))

    def set_min_axis(self, axis: typing.ForwardRef("Axis"), value: float):
        setattr(self, "min_" + str(axis), value)

    def max_axis(self, axis: typing.ForwardRef("Axis")) -> float:
        return getattr(self, "max_" + str(axis))

    def set_max_axis(self, axis: typing.ForwardRef("Axis"), value: float):
        setattr(self, "max_" + str(axis), value)

    def size_axis(self, axis: typing.ForwardRef("Axis")) -> float:
        return self.max_axis(axis) - self.min_axis(axis)

    @property
    def size_x(self) -> float:
        return self.max_x - self.min_x

    @property
    def size_y(self) -> float:
        return self.max_y - self.min_y

    @property
    def size_z(self) -> float:
        return self.max_z - self.min_z

    def intersect(
            self,
            other: typing.ForwardRef("Volume")
    ) -> typing.Optional[typing.ForwardRef("Volume")]:
        """
        This function calculates the intersection between two volumes, if any, and returns it.
        """
        if self.min_x > other.max_x or self.max_x < other.min_x:
            return None
        if self.min_y > other.max_y or self.max_y < other.min_y:
            return None
        if self.min_z > other.max_z or self.max_z < other.min_z:
            return None

        return Volume(
            max(self.min_x, other.min_x),
            min(self.max_x, other.max_x),
            max(self.min_y, other.min_y),
            min(self.max_y, other.max_y),
            max(self.min_z, other.min_z),
            min(self.max_z, other.max_z),
        )

    @classmethod
    def from_dict(cls, param) -> typing.ForwardRef("Volume"):
        # TODO error handling
        return Volume(
            param["min_x"], param["max_x"], param["min_y"], param["max_y"], param["min_z"], param["max_z"]
        )


class BroomrocketLogger(abc.ABC):
    """
    This class is an abstract logger for logging needs of this library. Subclasses of this class provide the
    implementation for logging. This is mainly needed due to Blender's logging API being tied to the operator API.
    """

    @abc.abstractmethod
    def debug(self, message: str):
        pass

    @abc.abstractmethod
    def info(self, message: str):
        pass

    @abc.abstractmethod
    def error(self, message: str):
        pass


class PythonLogger(BroomrocketLogger):
    """
    This logger is logging via the Python "logging" library. It is mainly used for testing purposes as Blender-based
    operations require logging via the Blender operator API.
    """

    def debug(self, message: str):
        logging.debug(message)

    def info(self, message: str):
        logging.info(message)

    def error(self, message: str):
        logging.error(message)


class LoadedMesh(abc.ABC):
    """
    A loaded mesh is a mesh that has been loaded into the 3D space and can be manipulated.
    """

    @property
    @abc.abstractmethod
    def name(self) -> str:
        """
        This property returns a unique name for the mesh.
        """
        pass

    @name.setter
    @abc.abstractmethod
    def name(self, name: str):
        """
        This setter changes the unique name for the mesh. This setter may change other meshes' names to avoid conflicts.
        """
        pass

    @property
    def size_x(self) -> float:
        return self.size.size_x

    @property
    def size_y(self) -> float:
        return self.size.size_y

    @property
    def size_z(self) -> float:
        return self.size.size_z

    @property
    def offsets_x(self) -> typing.Tuple[float, float]:
        return self.size.min_x - self.translation.x, self.size.max_x - self.translation.x

    @property
    def offsets_y(self) -> typing.Tuple[float, float]:
        return self.size.min_y - self.translation.y, self.size.max_y - self.translation.y

    def offsets_axis(self, axis: typing.ForwardRef("Axis")) -> typing.Tuple[float, float]:
        return self.size.min_axis(axis) - self.translation.get_axis(axis), self.size.max_axis(
            axis) - self.translation.get_axis(axis),

    @property
    def offsets_z(self) -> typing.Tuple[float, float]:
        return self.size.min_z - self.translation.z, self.size.max_z - self.translation.z

    @abc.abstractmethod
    def get_size_submesh_fallback(self, name: str) -> Volume:
        """
        Returns the size of a specified submesh if present, the size of the mesh otherwise.
        """
        pass

    @property
    @abc.abstractmethod
    def size(self) -> Volume:
        """
        Size returns the outer bounding box of the mesh.
        """
        pass

    @property
    @abc.abstractmethod
    def translation(self) -> Coordinate:
        """
        Translation returns the coordinate of the root/pivot point of the mesh. The returned coordinate must, when
        changed, translate those changes back to the mesh even when the setter below is not called explicitly.
        """
        pass

    @translation.setter
    @abc.abstractmethod
    def translation(self, translation: Coordinate):
        """
        This setter moves the mesh to have its root/pivot point to the specified coordinates.
        """
        pass


class TestLoadedMesh(LoadedMesh):
    """
    This loaded mesh implementation is useful for providing a test double of meshes.
    """
    _name: str
    _size: Volume
    _translation: Coordinate

    def __init__(self, name: str, size: Volume, translation: Coordinate):
        self._name = name
        self._size = size
        self._translation = translation

    @property
    def name(self) -> str:
        return self._name

    def get_size_submesh_fallback(self, name: str) -> Volume:
        return self._size

    @property
    def size(self) -> Volume:
        return self._size

    @property
    def translation(self) -> Coordinate:
        return self._translation


@dataclasses.dataclass
class GLTF:
    """
    GLTF is a representation of a directory tree containing a GLTF file and optionally, added textures. The "files"
    field is keyed with the relative filenames and its contents are the file contents themselves. The "gltf_file"
    attribute contains the filename for the primary GLTF file that should be loaded.
    """
    files: typing.Dict[str, bytes]
    gltf_file: str
    license_file: typing.Optional[str] = None

    def to_dict(self) -> typing.Dict[str, typing.Any]:
        return {
            "files": self.files,
            "gltf_file": self.gltf_file,
            "license_file": self.license_file,
        }


class Engine(abc.ABC):
    """
    Engine is a handler for a 3D space. The primary implementation will interface with Blender.
    """

    @abc.abstractmethod
    def load_gltf(self, name: str, data: GLTF, logger: BroomrocketLogger) -> LoadedMesh:
        """
        This method loads a GLTF with its associated data structure into the 3D space and returns the loaded mesh.
        Internally, the loaded mesh may consist of multiple meshes, but the engine must always return the root mesh.
        """
        pass

    @abc.abstractmethod
    def list_objects(self) -> typing.List[LoadedMesh]:
        """
        This method lists all objects in a 3D space. When objects with multiple meshes are encountered, they should be
        grouped together into one loaded mesh.
        """
        pass


class LoadableMesh(abc.ABC):
    """
    A loadable mesh is a reference to an item in an asset library or at a mesh provider that provides the ability to
    download a GLTF.
    """

    @abc.abstractmethod
    def load_gltf(self, parameters: typing.Dict[str, str], logger: BroomrocketLogger) -> GLTF:
        pass


class PlaceholderLoadableMesh(LoadableMesh):
    def load_gltf(self, parameters: typing.Dict[str, str], logger: BroomrocketLogger) -> GLTF:
        return GLTF(
            {
                "scene.gltf": """{"asset":{"generator":"Khronos glTF Blender I/O v3.5.30","version":"2.0"},"extensionsUsed":["KHR_materials_specular","KHR_materials_ior"],"scene":0,"scenes":[{"name":"Scene","nodes":[0]}],"nodes":[{"mesh":0,"name":"Placeholder"}],"materials":[{"alphaMode":"BLEND","doubleSided":true,"name":"Unknown Mesh","pbrMetallicRoughness":{"baseColorFactor":[0.800000011920929,0.800000011920929,0.800000011920929,0.5],"metallicFactor":0,"roughnessFactor":0.5}},{"doubleSided":true,"extensions":{"KHR_materials_specular":{"specularColorFactor":[2.371357614441398,2.371357614441398,2.371357614441398]},"KHR_materials_ior":{"ior":1.4500000476837158}},"name":"Unknown Cube Question Mark","pbrMetallicRoughness":{"baseColorFactor":[0.8000000715255737,0,0.694819986820221,1],"metallicFactor":0,"roughnessFactor":0}}],"meshes":[{"name":"Text.007","primitives":[{"attributes":{"POSITION":0,"TEXCOORD_0":1,"NORMAL":2},"indices":3,"material":0},{"attributes":{"POSITION":4,"TEXCOORD_0":5,"NORMAL":6},"indices":7,"material":1}]}],"accessors":[{"bufferView":0,"componentType":5126,"count":771,"max":[0.5000002384185791,1,0.5000002980232239],"min":[-0.5000000596046448,-2.9802322387695312e-8,-0.5000000596046448],"type":"VEC3"},{"bufferView":1,"componentType":5126,"count":771,"type":"VEC2"},{"bufferView":2,"componentType":5126,"count":771,"type":"VEC3"},{"bufferView":3,"componentType":5123,"count":2430,"type":"SCALAR"},{"bufferView":4,"componentType":5126,"count":702,"max":[0.5,1,0.5],"min":[-0.5000000596046448,-2.9802322387695312e-8,-0.5000000596046448],"type":"VEC3"},{"bufferView":5,"componentType":5126,"count":702,"type":"VEC2"},{"bufferView":6,"componentType":5126,"count":702,"type":"VEC3"},{"bufferView":7,"componentType":5123,"count":1962,"type":"SCALAR"}],"bufferViews":[{"buffer":0,"byteLength":9252,"byteOffset":0,"target":34962},{"buffer":0,"byteLength":6168,"byteOffset":9252,"target":34962},{"buffer":0,"byteLength":9252,"byteOffset":15420,"target":34962},{"buffer":0,"byteLength":4860,"byteOffset":24672,"target":34963},{"buffer":0,"byteLength":8424,"byteOffset":29532,"target":34962},{"buffer":0,"byteLength":5616,"byteOffset":37956,"target":34962},{"buffer":0,"byteLength":8424,"byteOffset":43572,"target":34962},{"buffer":0,"byteLength":3924,"byteOffset":51996,"target":34963}],"buffers":[{"byteLength":55920,"uri":"data:application/octet-stream;base64,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////vkJwLD+YB+Q9AAAAv0yLNT+3S/Y9AAAAv9z5Pj+R7fw9AAAAv2gZQz8vDvs9AAAAv+pXRz8ySfU9AAAAv7KdSz9aZOs9AAAAvxjTTz9lJd09AAAAv3LgUz8SUso9AAAAvxSuVz8gsLI9AAAAv1YkWz9OBZY9AAAAv4orXj+3Lmg9AAAAvwisYD8OWBk9AAAAvyaOYj99SHw8AAAAvzi6Yz9fXhy8AQAAv5QYZD+emRm9/v//vgAAgD8BAAC//v//vgAAgD8BAAC//v//vgAAgD8BAAC//v//vgAAgD8BAAC/gM1MPGQ7nz4AAAC/oNyoPELznj4AAAC/QK3oPDghnj4AAAC/4J8SPdjOnD4AAAC/oP0uPbAFmz7///++cCNJPU7PmD7///++wMRgPUA1lj7///++MJV1PRRBkz7///++KKSDPVz8jz7///++yMiKPaRwjD7///++SBKQPXyniD7///++aFqTPXCqhD7///+++HqUPRKDgD7///++cFqTPWi3eD7///++SBKQPVC9cD7///++yMiKPQAraT7///++KKSDPZATYj7///++MJV1PSCKWz7///++wMRgPcihVT7///++cCNJPaxtUD7///++sP0uPegATD7///++8J8SPZRuSD4AAAC/QK3oPNTJRT4AAAC/oNyoPMAlRD4AAAC/gM1MPICVQz4AAAC/gMOPO8glRD4AAAC/gP5eu9jJRT4AAAC/wOQwvJhuSD4AAAC/4C2RvOgATD4AAAC/cHnFvLBtUD4AAAC/ILz0vMyhVT4AAAC/gC4PvSCKWz4AAAC/mOEgvZQTYj4AAAC/2CovvQQraT4AAAC/4L05vVi9cD4AAAC/IE5AvWy3eD4AAAC/OI9CvRKDgD4AAAC/IE5AvXCqhD4AAAC/2L05vXqniD4AAAC/2CovvaRwjD4AAAC/mOEgvVz8jz4AAAC/gC4PvRRBkz4AAAC/ILz0vEA1lj4AAAC/cHnFvEzPmD4AAAC/4C2RvLAFmz4AAAC/wOQwvNjOnD4AAAC/gP5euzghnj4AAAC/gMOPO0Dznj4AAAC/aA6tPSCFSz////++QFWnPWSoSz////++UGehPcLPSz////++eDubPdz5Sz////++oMiUPVIlTD////++sAWOPchQTD////++iOmGPeJ6TD////++MNZ+PUCiTD////++gAJvPYTFTD////++wEVePVTjTD////++0I1MPVD6TD////++cMg5PRoJTT////++gOMlPVYOTT////++oE38PADqTD8AAAC/IPOxPCB/TD8AAAC/QB1aPOTQSz8AAAC/gN63O37iSj8AAAC/AKevuhy3ST8AAAC/QMH1u+xRSD8AAAC/ICVSvCC2Rj8AAAC/wImNvOTmRD8AAAC/oH6qvGznQj8AAAC/sJm/vOa6QD8AAAC/oIPMvIJkPj8AAAC/AOXQvGznOz8AAAC/gNe+vP4uNj8AAAC/gO6MvO6iMD8AAAC/4BEDvEY2Kz8AAAC/ANBnOwzcJT8AAAC/IDuIPEiHID8AAAC/YNv5PAIrGz8AAAC/4L01PUC6FT////++cF5rPQwoED////++8E+NPWxnCj////++WCmgPWhrBD////++mKOsPQ5O/D7///++ACexPaAa7z7///++4GqwPeSK6T7///++0CyuPYpc5D7///++SF6qPTiJ3z7///++sPCkPYwK2z7///++cNWdPSba1j7///++CP6UParx0j7///++4FuKPbhKzz7///++wMB7Pe7eyz7///++APpePfCnyD7///++YEY+PVyfxT7///++wIgZPdi+wj7///++AEjhPAAAwD4AAAC/4AjhPFpZzT4AAAC/gHmtPFwM2z4AAAC/QMUgPMQg6T4AAAC/wMqxu06e9z4AAAC/gD2/vFpGAz8AAAC/gBovvdz5Cj8AAAC/CMh/vYjtEj8AAAC/fGGmvT4lGz8BAAC/aJPIvdykIz8BAAC/iAfkvUJwLD8AAAC/pEv2vUyLNT8AAAC/fO38vdz5Pj8AAAC/HA77vWgZQz8AAAC/IEn1vepXRz8AAAC/SGTrvbKdSz8AAAC/VCXdvRjTTz8AAAC/AFLKvXLgUz8BAAC/DLCyvRSuVz8BAAC/PAWWvVYkWz8AAAC/kC5ovYorXj8AAAC/6FcZvQisYD8AAAC/4Ed8vCaOYj8AAAC/wF4cPDi6Yz8AAAC/wJkZPZQYZD////++AgAAPwAAAAD7//++AgAAPwAAAAD7//++AgAAPwAAAAD7//++BAAAPwAAgD/9//++BAAAPwAAgD/9//++BAAAPwAAgD/9//++BAAAPwAAgD/9//++AAAAP2I7nz7HzUw8AAAAP0Lznj7C3Kg8AAAAPzghnj5ureg8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AAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAgAAAgL8AAACAAAAAgAAAgL8AAACAAAAAgAAAgL8AAACAAAAAgAAAgL8AAACAAAAAgAAAgL8AAACAAAAAgAAAgL8AAAAAAAAAgAAAgL8AAAAAAAAAgAAAgL8AAAAAAAAAgAAAgL8AAAAAAAAAgAAAgL8AAAAAAAAAgAAAgL8AAAAAAAAAgAAAgL8AAAAAAAAAgAAAgL8AAAAAAAAAgAAAgL8AAAAAAAAAgAAAgL8AAAAAAAAAgAAAgL8AAACAAAAAgAAAgL8AAACAAAAAgAAAgL8AAACAAAAAgAAAgL8AAACAAAAAgAAAgL8AAACAAAAAgAAAgL8AAACAAAAAgAAAgL8AAACAAAAAgAAAgL8AAACAAAAAgAAAgL8AAACAAAAAgAAAgL8AAACAAAAAgAAAgL8AAAAAAAAAgAAAgL8AAAAAAAAAgAAAgL8AAAAAAAAAgAAAgL8AAAAAAAAAgAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAgAAAgL8AAACAAAAAgAAAgL8AAACAAAAAgAAAgL8AAACAAAAAgAAAgL8AAACAAAAAgAAAgL8AAACAAAAAgAAAgL8AAACAAAAAgAAAgL8AAACAAACAvwAAAIAAAACAAAAAAAAAgL8AAACAAACAvwAAAIAAAACAAAAAAAAAgL8AAACAAAAAAAAAAAAAAIC/AACAvwAAAIAAAACAAAAAgAAAgL8AAACAAAAAgAAAgL8AAACAAAAAgAAAgL8AAACAAAAAAAAAAAAAAIA/AAAAgAAAAAAAAIA/AACAvwAAAAAAAACAAAAAAAAAgL8AAACAAAAAAAAAAAAAAIA/AAAAAAAAgL8AAACAAAAAgAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAgAAAAAAAAIA/AAAAgAAAAAAAAIA/AAAAgAAAAAAAAIA/AAAAgAAAAAAAAIA/AAAAgAAAAAAAAIA/AAAAgAAAAAAAAIA/AAAAgAAAAAAAAIA/AAAAgAAAAAAAAIA/AAAAgAAAAAAAAIA/AAAAgAAAAAAAAIA/AAAAgAAAAAAAAIA/AAAAgAAAAAAAAIA/AAAAgAAAAAAAAIA/AAAAgAAAAAAAAIA/AAAAgAAAAAAAAIA/AAAAgAAAAAAAAIA/AAAAgAAAAAAAAIA/AAAAgAAAAAAAAIA/AAAAgAAAAAAAAIA/AAAAgAAAAAAAAIA/AAAAgAAAAAAAAIA/AAAAgAAAAAAAAIA/AAAAgAAAAAAAAIA/AAAAgAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAgAAAAAAAAIA/AAAAgAAAAAAAAIA/AAAAgAAAAAAAAIA/AAAAgAAAAAAAAIA/AAAAgAAAAAAAAIA/AAAAgAAAAAAAAIA/AAAAgAAAAAAAAIA/AAAAgAAAAAAAAIA/AAAAgAAAAAAAAIA/AAAAgAAAAAAAAIA/AAAAgAAAAAAAAIA/AAAAgAAAAIAAAIA/AAAAgAAAAIAAAIA/AAAAgAAAAAAAAIA/AAAAgAAAAAAAAIA/AAAAgAAAAAAAAIA/AAAAgAAAAIAAAIA/AAAAgAAAAIAAAIA/AAAAgAAAAIAAAIA/AAAAgAAAAIAAAIA/AAAAgAAAAIAAAIA/AAAAgAAAAIAAAIA/AAAAgAAAAIAAAIA/AAAAgAAAAIAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAgD8AAACAAACAvwAAAIAAAACAAAAAgAAAAIAAAIA/AAAAAAAAgD8AAAAAAAAAgAAAAAAAAIA/AAAAgAAAgD8AAACAAACAPwAAAIAAAAAAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAgAAAAAAAAIA/AACAPwAAAIAAAAAAAACAvwAAAAAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAIAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAIAAAACAAACAvwAAAAAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAAAAAACAAACAvwAAAIAAAACAAACAvwAAAAAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAAAAAACAAACAvwAAAIAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAIAAAACAAAAAAAAAAIAAAIC/AAAAAAAAgD8AAACAAACAvwAAAAAAAACAAAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAgAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAgAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAgAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAgAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAgAAAAIAAAIC/AAAAgAAAAIAAAIC/AAAAgAAAAAAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAgD8AAACAAACAPwAAAIAAAAAAAAAAAAAAAIAAAIC/AACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAIAAAAAAAACAPwAAAIAAAAAAAACAPwAAAIAAAAAAAACAPwAAAIAAAAAAAACAPwAAAIAAAAAAAACAPwAAAIAAAAAAAACAPwAAAIAAAAAAAACAPwAAAIAAAAAAAACAPwAAAIAAAAAAAACAPwAAAIAAAAAAAACAPwAAAIAAAAAAAACAPwAAAAAAAACAAACAPwAAAIAAAAAAAACAPwAAAIAAAAAAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAACAAACAPwAAAIAAAAAAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAIAAAAAAAACAPwAAAIAAAACAAACAPwAAAIAAAAAAAACAPwAAAIAAAAAAAACAPwAAAIAAAAAAAACAPwAAAIAAAAAAAACAPwAAAIAAAAAAAACAPwAAAIAAAACAAACAPwAAAIAAAAAAAACAPwAAAIAAAAAAAACAPwAAAIAAAAAAAACAPwAAAIAAAAAAAACAPwAAAIAAAAAAAACAPwAAAIAAAAAAAACAPwAAAIAAAAAAAACAPwAAAIAAAAAAAACAPwAAAIAAAAAAAACAPwAAAIAAAAAAAACAPwAAAIAAAAAAAACAPwAAAIAAAAAAAACAPwAAAIAAAAAAAACAPwAAAIAAAAAAAACAPwAAAIAAAAAAAACAPwAAAIAAAAAAAACAPwAAAIAAAAAAAACAPwAAAIAAAAAAAACAPwAAAIAAAAAAAACAPwAAAIAAAAAAAACAPwAAAIAAAAAAAACAPwAAAIAAAAAAAACAPwAAAIAAAAAAAACAPwAAAIAAAAAAAACAPwAAAIAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAAAAAACAPwAAAIAAAAAAAACAPwAAAIAAAAAAAACAPwAAAIAAAACAAACAPwAAAIAAAACAAACAPwAAAIAAAACAAACAPwAAAIAAAAAAAACAPwAAAIAAAAAAAACAPwAAAIAAAAAAAACAPwAAAIAAAAAAAACAPwAAAIAAAAAAAACAPwAAAIAAAAAAAACAPwAAAAAAAACAAACAPwAAAAAAAAAAAACAPwAAAIAAAAAAAACAPwAAAIAAAAAAAACAPwAAAAAAAAAAAAAAgAAAgD8AAACAAAAAgAAAgD8AAACAAAAAgAAAgD8AAACAAAAAgAAAgD8AAACAAAAAgAAAgD8AAACAAAAAgAAAgD8AAACAAAAAgAAAgD8AAACAAAAAgAAAgD8AAACAAAAAgAAAgD8AAACAAAAAgAAAgD8AAACAAAAAgAAAgD8AAACAAAAAgAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAF7dRuQAAgD8AAACAAAAAAAAAgD8AAACAF7dRuQAAgD8AAACAAAAAAAAAgD8AAACAF7dRuQAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAgAAAgD8AAACAAAAAgAAAgD8AAACAAAAAgAAAgD8AAACAAAAAgAAAgD8AAACAAAAAgAAAgD8AAACAAAAAgAAAgD8AAACAAAAAgAAAgD8AAACAAAAAgAAAgD8AAACAAAAAgAAAgD8AAACAAAAAgAAAgD8AAACAAAAAgAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAgAAAgD8AAACAAAAAgAAAgD8AAACAAAAAgAAAgD8AAACAAAAAgAAAgD8AAACAAAAAgAAAgD8AAACAAAAAgAAAgD8AAACAAAAAgAAAgD8AAACAAAAAgAAAgD8AAACAAAAAgAAAgD8AAACAAAAAgAAAgD8AAACAAAAAgAAAgD8AAACAAAAAgAAAgD8AAACAAAAAgAAAgD8AAACAAAAAgAAAgD8AAACAAAAAgAAAgD8AAACAAAAAgAAAgD8AAACAAAAAgAAAgD8AAACAAAAAgAAAgD8AAACAAAAAgAAAgD8AAACAAAAAgAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAANgBxADcAOgBwADsAPQA8AG8AdwB4AIEAhwBxAHIAhwByAHMAdwCBAIcAdgB3AIcAhwBzAHQAdQB2AIcAhwB0AHUAhQBpAGoAhQBqAGsAUAAwADEAMgAzADQAUAAxADIATwBQADIAMgA0ADUANQA2ADcANwA4ADkAOQA6ADsAOwA8AD0APQA+AD8APwBAAEEAQQBCAEMAQwBEAEUARQBGAEcARwBIAEkASQBKAEsASwBMAE0ATgBPADIASwBNAE4ARwBJAEsAQwBFAEcAPwBBAEMAOwA9AD8ANwA5ADsAMgA1ADcASwBOADIAQwBHAEsAOwA/AEMAMgA3ADsAQwBLADIAMgA7AEMAFwAWABkAFwAZABgAgAB4ADAAMwAyADEAMQAwADQAMwAxADQAegBVAFYAegBWAFcACgALAHoACQAKAHoAegBXAFgAegBYAFkACAAJAHoABwAIAHoAegBZAFoAegBaAFsABgAHAHoABQAGAHoAegBbAFwAegBcAF0ABAAFAHoABAB6AF0ABABdAF4AAwAEAF4AXwBgAAEAAwBeAF8AXwABAAIAXwACAAMAgAAwAFAAgABQAFEAVQB/AIAAVABVAIAAgABRAFIAUwBUAIAAUgBTAIAAaQCFACUAaQAlACYAaABpACYAaAAmACcAZwBoACcAZwAnACgAZABlAGYAZgBnACgAZgAoACkAYwBkAGYAYQBiAGMAAQBgAGEAAAABAGEAYQBjAGYAZgApACoAZgAqACsAAABhAGYALwAAAGYAZgArACwAZgAsAC0ALgAvAGYALQAuAGYAegALAAwAegAMAA0AFgAXAHoAFQAWAHoAegANAA4AegAOAA8AFAAVAHoAEwAUAHoAegAPABAAegAQABEAEgATAHoAEQASAHoAJAAlAIUAhQAaABsAhQAbABwAIwAkAIUAIgAjAIUAhQAcAB0AhQAdAB4AIQAiAIUAIAAhAIUAhQAeAB8AhQAfACAAGQAaAIUAhQB8ABcAGAAZAIUAhQAXABgAbQCHAIUAhQBrAGwAhQBsAG0AcABxAIcAcACHAG8AbwCHAG4AhwBtAG4AvgC/APkAwgDDAPgAxQD3AMQA+gD5AAsBCwEEAQABCwEAAf8A+wD6AAsB/AD7AAsBCwH/AP4A/QD8AAsB/gD9AAsBBgHzAPIABgHyAPEAuQC4ANgAuQDYANcAvAC7ALoAugC5ANcA1gDVANQAugDXANYAvQC8ALoAvwC+AL0AwQDAAL8AwwDCAMEAxQDEAMMAxwDGAMUAyQDIAMcAywDKAMkAzQDMAMsAzwDOAM0A0QDQAM8A0wDSANEA1gDUANMAvQC6ANYAwQC/AL0AxQDDAMEAyQDHAMUAzQDLAMkA0QDPAM0A1gDTANEAwQC9ANYAyQDFAMEA0QDNAMkAwQDWANEA0QDJAMEAnwChAJ4AnwCgAKEAAQG4AAABuwC8ALgAuAC5ALoAuwC4ALoA3gDdAIIAggCTAJIAggCSAJEA3wDeAIIA4ADfAIIAggCRAJAAggCQAI8A4QDgAIIA4gDhAIIAggCPAI4AggCOAI0A4wDiAIIA5ADjAIIAggCNAIwA5ACCAIwA5QDkAIwA5QCMAIsA5gDlAIsAigCJAOgA5gCLAIoAigDoAOcAigDnAOYA2AC4AAEBAQGGAN0AAQHdANwA2QDYAAEB2gDZAAEBAQHcANsAAQHbANoArQAGAfEArQDxAPAArgCtAPAArgDwAO8ArwCuAO8A7gDtAOwArwDvAO4AsACvAO4A7gDsAOsA6wDqAOkA6QDoAIkA6QCJAIgA7gDrAOkAsQCwAO4AsgCxAO4A7gDpAIgA7gCIALcAswCyAO4AtACzAO4A7gC3ALYAtQC0AO4A7gC2ALUAlACTAIIAggCfAJ4AggCeAJ0AlQCUAIIAlgCVAIIAggCdAJwAggCcAJsAlwCWAIIAmACXAIIAggCbAJoAmQCYAIIAggCaAJkAowCiAAYBBgGtAKwABgGsAKsApACjAAYBpQCkAAYBBgGrAKoABgGqAKkApgClAAYBpwCmAAYBBgGpAKgAqACnAAYBBgGiAKEAoACfAIMABgGhAKAAoACDAAYBBgELAfUA9ADzAAYB9QD0AAYB+AD3AAsB+AALAfkA9wD2AAsB9gD1AAsBQwFEAX4BRwFIAX0BSgF8AUkBfwF+AQMBAwGJAYUBAwGFAYQBgAF/AQMBgQGAAQMBAwGEAYMBggGBAQMBgwGCAQMBhAB4AXcBhAB3AXYBPgE9AV0BPgFdAVwBQQFAAT8BPwE+AVwBWwFaAVkBPwFcAVsBQgFBAT8BRAFDAUIBRgFFAUQBSAFHAUYBSgFJAUgBTAFLAUoBTgFNAUwBUAFPAU4BUgFRAVABVAFTAVIBVgFVAVQBWAFXAVYBWwFZAVgBQgE/AVsBRgFEAUIBSgFIAUYBTgFMAUoBUgFQAU4BVgFUAVIBWwFYAVYBRgFCAVsBTgFKAUYBVgFSAU4BRgFbAVYBVgFOAUYBJAEmASMBJAElASYBhgE9AYUBQAFBAT0BPQE+AT8BQAE9AT8BYwFiAXkAeQAYARcBeQAXARYBZAFjAXkAZQFkAXkAeQAWARUBeQAVARQBZgFlAXkAZwFmAXkAeQAUARMBeQATARIBaAFnAXkAaQFoAXkAeQASAREBaQF5ABEBagFpAREBagERARABawFqARABDwEOAW0BawEQAQ8BDwFtAWwBDwFsAWsBXQE9AYYBhgF+AGIBhgFiAWEBXgFdAYYBXwFeAYYBhgFhAWABhgFgAV8BMgGEAHYBMgF2AXUBMwEyAXUBMwF1AXQBNAEzAXQBcwFyAXEBNAF0AXMBNQE0AXMBcwFxAXABcAFvAW4BbgFtAQ4BbgEOAQ0BcwFwAW4BNgE1AXMBNwE2AXMBcwFuAQ0BcwENATwBOAE3AXMBOQE4AXMBcwE8ATsBOgE5AXMBcwE7AToBGQEYAXkAeQAkASMBeQAjASIBGgEZAXkAGwEaAXkAeQAiASEBeQAhASABHAEbAXkAHQEcAXkAeQAgAR8BHgEdAXkAeQAfAR4BKAEnAYQAhAAyATEBhAAxATABKQEoAYQAKgEpAYQAhAAwAS8BhAAvAS4BKwEqAYQALAErAYQAhAAuAS0BLQEsAYQAhAAnASYBJQEkAXsAhAAmASUBJQF7AIQAhAADAXoBeQF4AYQAegF5AYQAfQF8AQMBfQEDAX4BfAF7AQMBewF6AQMBwAHBAfsBxAHFAfoBxwH5AcYB/AH7AYcBhwEJAgIChwECAgEC/QH8AYcB/gH9AYcBhwEBAgAC/wH+AYcBAAL/AYcBfQD1AfQBfQD0AfMBuwG6AdoBuwHaAdkBvgG9AbwBvAG7AdkB2AHXAdYBvAHZAdgBvwG+AbwBwQHAAb8BwwHCAcEBxQHEAcMBxwHGAcUByQHIAccBywHKAckBzQHMAcsBzwHOAc0B0QHQAc8B0wHSAdEB1QHUAdMB2AHWAdUBvwG8AdgBwwHBAb8BxwHFAcMBywHJAccBzwHNAcsB0wHRAc8B2AHVAdMBwwG/AdgBywHHAcMB0wHPAcsBwwHYAdMB0wHLAcMBoQGjAaABoQGiAaMBBgK6AQICvQG+AboBugG7AbwBvQG6AbwB4AHfAQMCAwKVAZQBAwKUAZMB4QHgAQMC4gHhAQMCAwKTAZIBAwKSAZEB4wHiAQMC5AHjAQMCAwKRAZABAwKQAY8B5QHkAQMC5gHlAQMCAwKPAY4B5gEDAo4B5wHmAY4B5wGOAY0B6AHnAY0BjAGLAeoB6AGNAYwBjAHqAekBjAHpAegB2gG6AQYCBgIFAt8BBgLfAd4B2wHaAQYC3AHbAQYCBgLeAd0BBgLdAdwBrwF9APMBrwHzAfIBsAGvAfIBsAHyAfEBsQGwAfEB8AHvAe4BsQHxAfABsgGxAfAB8AHuAe0B7QHsAesB6wHqAYsB6wGLAYoB8AHtAesBswGyAfABtAGzAfAB8AHrAYoB8AGKAbkBtQG0AfABtgG1AfAB8AG5AbgBtwG2AfAB8AG4AbcBlgGVAQMCAwKhAaABAwKgAZ8BlwGWAQMCmAGXAQMCAwKfAZ4BAwKeAZ0BmQGYAQMCmgGZAQMCAwKdAZwBmwGaAQMCAwKcAZsBpQGkAX0AfQCvAa4BfQCuAa0BpgGlAX0ApwGmAX0AfQCtAawBfQCsAasBqAGnAX0AqQGoAX0AfQCrAaoBqgGpAX0AfQCkAaMBogGhAQQCfQCjAaIBogEEAn0AfQCHAfcB9gH1AX0A9wH2AX0A+gH5AYcB+gGHAfsB+QH4AYcB+AH3AYcBQAJBAnsCRAJFAnoCRwJ5AkYCfAJ7AggCCAIMAYICCAKCAoECfQJ8AggCfgJ9AggCCAKBAoACfwJ+AggCgAJ/AggChgJ1AnQChgJ0AnMCOwI6AloCOwJaAlkCPgI9AjwCPAI7AlkCWAJXAlYCPAJZAlgCPwI+AjwCQQJAAj8CQwJCAkECRQJEAkMCRwJGAkUCSQJIAkcCSwJKAkkCTQJMAksCTwJOAk0CUQJQAk8CUwJSAlECVQJUAlMCWAJWAlUCPwI8AlgCQwJBAj8CRwJFAkMCSwJJAkcCTwJNAksCUwJRAk8CWAJVAlMCQwI/AlgCSwJHAkMCUwJPAksCQwJYAlMCUwJLAkMCIQIjAiACIQIiAiMCCAE6AoICPQI+AjoCOgI7AjwCPQI6AjwCYAJfAoMCgwIVAhQCgwIUAhMCYQJgAoMCYgJhAoMCgwITAhICgwISAhECYwJiAoMCZAJjAoMCgwIRAhACgwIQAg8CZQJkAoMCZgJlAoMCgwIPAg4CZgKDAg4CZwJmAg4CZwIOAg0CaAJnAg0CDAILAmoCaAINAgwCDAJqAmkCDAJpAmgCWgI6AggBCAGFAl8CCAFfAl4CWwJaAggBXAJbAggBCAFeAl0CCAFdAlwCLwKGAnMCLwJzAnICMAIvAnICMAJyAnECMQIwAnECcAJvAm4CMQJxAnACMgIxAnACcAJuAm0CbQJsAmsCawJqAgsCawILAgoCcAJtAmsCMwIyAnACNAIzAnACcAJrAgoCcAIKAjkCNQI0AnACNgI1AnACcAI5AjgCNwI2AnACcAI4AjcCFgIVAoMCgwIhAiACgwIgAh8CFwIWAoMCGAIXAoMCgwIfAh4CgwIeAh0CGQIYAoMCGgIZAoMCgwIdAhwCGwIaAoMCgwIcAhsCJQIkAoYChgIvAi4ChgIuAi0CJgIlAoYCJwImAoYChgItAiwChgIsAisCKAInAoYCKQIoAoYChgIrAioCKgIpAoYChgIkAiMCIgIhAoQChgIjAiICIgKEAoYChgIIAncCdgJ1AoYCdwJ2AoYCegJ5AggCegIIAnsCeQJ4AggCeAJ3AggCwALBAvsCxALFAvoCxwL5AsYC/AL7AogBiAEFAQIDiAECAwED/QL8AogB/gL9AogBiAEBAwAD/wL+AogBAAP/AogBBwL1AvQCBwL0AvMCuwK6AtoCuwLaAtkCvgK9ArwCvAK7AtkC2ALXAtYCvALZAtgCvwK+ArwCwQLAAr8CwwLCAsECxQLEAsMCxwLGAsUCyQLIAscCywLKAskCzQLMAssCzwLOAs0C0QLQAs8C0wLSAtEC1QLUAtMC2ALWAtUCvwK8AtgCwwLBAr8CxwLFAsMCywLJAscCzwLNAssC0wLRAs8C2ALVAtMCwwK/AtgCywLHAsMC0wLPAssCwwLYAtMC0wLLAsMCnwKjAp0CngKgAqICAgG6AgIDvQK+AroCugK7ArwCvQK6ArwC4ALfAgcBBwGSApECBwGRApAC4QLgAgcB4gLhAgcBBwGQAo8CBwGPAo4C4wLiAgcB5ALjAgcBBwGOAo0CBwGNAowC5QLkAgcB5gLlAgcBBwGMAosC5gIHAYsC5wLmAosC5wKLAooC6ALnAooCiQKIAuoC6AKKAokCiQLqAukCiQLpAugC2gK6AgIBAgEKAd8CAgHfAt4C2wLaAgIB3ALbAgIBAgHeAt0CAgHdAtwCrwIHAvMCrwLzAvICsAKvAvICsALyAvECsQKwAvEC8ALvAu4CsQLxAvACsgKxAvAC8ALuAu0C7QLsAusC6wLqAogC6wKIAocC8ALtAusCswKyAvACtAKzAvAC8ALrAocC8AKHArkCtQK0AvACtgK1AvAC8AK5ArgCtwK2AvAC8AK4ArcCkwKSAgcBBwGfAp0CBwGdApwClAKTAgcBlQKUAgcBBwGcApsCBwGbApoClgKVAgcBlwKWAgcBBwGaApkCmAKXAgcBBwGZApgCpQKkAgcCBwKvAq4CBwKuAq0CpgKlAgcCpwKmAgcCBwKtAqwCBwKsAqsCqAKnAgcCqQKoAgcCBwKrAqoCqgKpAgcCBwKkAqMCoQKfAgkBBwKjAqECoQIJAQcCBwKIAfcC9gL1AgcC9wL2AgcC+gL5AogB+gKIAfsC+QL4AogB+AL3AogBNolBvgAAAADZzEy8ehlCvgAAAABN3Ki8jL1DvgAAAAD5rOi8TGJGvgAAAADCnxK9nvRJvgAAAACD/S69YmFOvgAAAABJI0m9fpVTvgAAAACfxGC91H1ZvgAAAAAQlXW9RgdgvgAAAAATpIO9th5nvgAAAAC2yIq9CLFuvgAAAAA2EpC9Hqt2vgAAAABZWpO92vl+vgAAAADkepS9TKSDvgAAAABZWpO9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cHnFvEzPmD4AAAC/4C2RvLAFmz4AAAC/wOQwvNjOnD4AAAC/gP5euzghnj4AAAC/gMOPO0Dznj4AAAC/aA6tPSCFSz////++oMiUPVIlTD////++sAWOPchQTD////++iOmGPeJ6TD////++MNZ+PUCiTD////++gAJvPYTFTD////++wEVePVTjTD////++0I1MPVD6TD////++cMg5PRoJTT////++gOMlPVYOTT////++oE38PADqTD8AAAC/IPOxPCB/TD8AAAC/QB1aPOTQSz8AAAC/gN63O37iSj8AAAC/AKevuhy3ST8AAAC/QMH1u+xRSD8AAAC/ICVSvCC2Rj8AAAC/wImNvOTmRD8AAAC/oH6qvGznQj8AAAC/sJm/vOa6QD8AAAC/oIPMvIJkPj8AAAC/AOXQvGznOz8AAAC/gNe+vP4uNj8AAAC/gO6MvO6iMD8AAAC/4BEDvEY2Kz8AAAC/ANBnOwzcJT8AAAC/IDuIPEiHID8AAAC/YNv5PAIrGz8AAAC/4L01PUC6FT////++cF5rPQwoED////++8E+NPWxnCj////++WCmgPWhrBD////++mKOsPQ5O/D7///++ACexPaAa7z7///++4GqwPeSK6T7///++0CyuPYpc5D7///++SF6qPTiJ3z7///++sPCkPYwK2z7///++cNWdPSba1j7///++CP6UParx0j7///++4FuKPbhKzz7///++wMB7Pe7eyz7///++APpePfCnyD7///++YEY+PVyfxT7///++wIgZPdi+wj7///++AEjhPAAAwD4AAAC/4AjhPFpZzT4AAAC/gHmtPFwM2z4AAAC/QMUgPMQg6T4AAAC/wMqxu06e9z4AAAC/gD2/vFpGAz8AAAC/gBovvdz5Cj8AAAC/CMh/vYjtEj8AAAC/fGGmvT4lGz8BAAC/aJPIvdykIz8BAAC/iAfkvUJwLD8AAAC/pEv2vUyLNT8AAAC/fO38vdz5Pj8AAAC/HA77vWgZQz8AAAC/IEn1vepXRz8AAAC/SGTrvbKdSz8AAAC/VCXdvRjTTz8AAAC/AFLKvXLgUz8BAAC/DLCyvRSuVz8BAAC/PAWWvVYkWz8AAAC/kC5ovYorXj8AAAC/6FcZvQisYD8AAAC/4Ed8vCaOYj8AAAC/wF4cPDi6Yz8AAAC/wJkZPZQYZD////++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AAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAgAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAgAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAgAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAgAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAgAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAgAAAgL8AAACAAAAAAAAAgL8AAACAAAAAgAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAgAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAgL8AAACAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAAAAAACAvwAAAAAAAAAAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAAAAAACAvwAAAAAAAAAAAACAvwAAAAAAAAAAAACAvwAAAAAAAAAAAACAvwAAAAAAAAAAAACAvwAAAIAAAACAAACAvwAAAIAAAAAAAACAvwAAAIAAAAAAAACAvwAAAIAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAAAAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAIAAAAAAAACAvwAAAIAAAAAAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAIAAAACAAACAvwAAAIAAAAAAAACAvwAAAIAAAAAAAACAvwAAAAAAAAAAAACAvwAAAAAAAAAAAACAvwAAAIAAAACAAACAvwAAAIAAAACAAACAvwAAAAAAAAAAAACAvwAAAAAAAAAAAACAvwAAAAAAAAAAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAAAAAACAAACAvwAAAIAAAAAAAAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAgAAAAAAAAIC/AAAAgAAAAAAAAIC/AAAAgAAAAAAAAIC/AAAAAAAAAIAAAIC/AAAAgAAAAAAAAIC/AAAAgAAAAAAAAIC/AAAAgAAAAAAAAIC/AAAAgAAAAAAAAIC/AAAAgAAAAAAAAIC/AAAAgAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAgAAAAAAAAIC/AAAAAAAAAIAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAAAAAACAPwAAAIAAAACAAACAPwAAAIAAAACAAACAPwAAAIAAAAAAAACAPwAAAIAAAACAAACAPwAAAIAAAACAAACAPwAAAIAAAACAAACAPwAAAIAAAACAAACAPwAAAIAAAACAAACAPwAAAIAAAAAAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAIAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAACAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAIAAAACAAACAPwAAAIAAAAAAAACAPwAAAAAAAACAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAACAAACAPwAAAIAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAAAAAACAAACAPwAAAIAAAAAAAACAPwAAAIAAAACAAACAPwAAAIAAAACAAACAPwAAAIAAAACAAACAPwAAAIAAAACAAACAPwAAAIAAAACAAACAPwAAAIAAAACAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAF7fRuAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAgAAAgD8AAACAAAAAgAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAgAAAgD8AAACAAAAAAAAAgD8AAACAAAAAgAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAgAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAgAAAgD8AAACAAAAAgAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAgAAAgD8AAACAAAAAgAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAF7fRuAAAgD8AAACAAAAAAAAAgD8AAACAF7fRuAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAbxIDOgAAgD8AAACAAAAAgAAAgD8AAACAbxIDOgAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAgAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAgAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAgAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAgAAAgD8AAACAAAAAgAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAbxIDOgAAgD8AAACAAAAAgAAAgD8AAAAAAAAAgAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAgAAAgD8AAACALgBzAHIALgByAHEALgBxAHAALgBwAG8ALgBvAG4ALgBuAG0ALgBtAC8ALwBtADAAMABtADEAMQBtAGwAMgBsADMAMwBsADQANABsADUANQBsAGsANgBrADcANwBrAGoAOQA4AGoAOgA5AGoAOwA6AGoAOwBqAGkAPAA7AGkAPQA8AGkAPgA9AGkAfgCZAJoAfgCaAH0AQAA/AGgAigKwArECigKxAokCQgBBAGcAjAKvArACjAKwAosCRABDAGYAjgKuAq8CjgKvAo0CjwKtAq4CjwKuAo4CRwBGAGQApAG/AcABpAHAAaMBSQBIAGMApgG+Ab8BpgG/AaUBlAKqAqsClAKrApMClQKpAqoClQKqApQCTQBMAGAAHgIvAjACHgIwAh0CNwFGAUcBNwFHATYBUABPAF4AmgKmAqcCmgKnApkCUgBRAF0AUwBSAF0AUwBdAFwAVABTAFwAVQBUAFwAVgBVAFwAVwBWAFwAVwBcAFsAAQAAAC0AAgABAC0AAgAtACwAAwACACwAAwAsACsABAADACsABAArACoABQAEACoABQAqACkABgAFACkABgApACgABwAGACgAfACbAJwAfACcAHsAZQGCAYMBZQGDAWQBTwJqAmsCTwJrAk4C2wH0AfUB2wH1AdoB9AALAQwB9AAMAfMA9QAKAQsB9QALAfQADQAiACEA3gHwAfEB3gHxAd0B9wAHAQgB9wAIAfYA+AAGAQcB+AAHAfcAhQCRAJIAhQCSAIQAEQAdABwAEgARABwAEgAcABsAEwASABsAEwAbABoAFAATABoAFAAaABkAFQAUABkAFQAZABgAFgAVABgAFgAYABcAVwBbAFoAWgBZAFgAWgBYAFcAogDmAOcAogDlAOYAogDkAOUAogDjAOQAogDiAOMAogDhAOIAogCjAOEAowCkAOEApAClAOEApQDgAOEApgCnAOAApwCoAOAAqACpAOAAqQDfAOAAqgCrAN8AqwDeAN8ArQDeAKwArgDeAK0ArwDeAK4ArwDdAN4AsADdAK8AsQDdALAAsgDdALEAiAKxArICiAKyAocCtADcALMAxQDRANIAxQDSAMQAtgDbALUAnwHCAcMBnwHDAZ4BuADaALcAoQHBAcIBoQHCAaABZQBkAEYAZQBGAEUAuwDYALoAmwHEAcUBmwHFAZoBvQDXALwAMgFKAUsBMgFLATEBMwFJAUoBMwFKATIBHAIwAjECHAIxAhsCwQDUAMAAYABfAE4AYABOAE0AQQBAAGgAQQBoAGcAxADSAMMAOQFFAUYBOQFGATgBxgDRAMUAxwDRAMYAxwDQANEAyADQAMcAyQDQAMgAygDQAMkAywDQAMoAywDPANAAdQChAHQAdgChAHUAdgCgAKEAdwCgAHYAdwCfAKAAeACfAHcAeACeAJ8AeQCeAHgAeQCdAJ4AegCdAHkAegCcAJ0AewCcAHoAZAGDAYQBZAGEAWMBVgJiAmMCVgJjAlUC8gANAQ4B8gAOAfEAZwGAAYEBZwGBAWYB3AHzAfQB3AH0AdsBDQAMACMADQAjACIAgQCVAJYAqwG6AbsBqwG7AaoBDwAOACAADwAgAB8AEAAPAB8AEAAfAB4AbQF5AXoBbQF6AWwBhQCQAJEAhgCQAIUAhgCPAJAAhwCPAIYAhwCOAI8AiACOAIcAiACNAI4AiQCNAIgAiQCMAI0AigCMAIkAigCLAIwAzgDPAMsAywDMAM0AywDNAM4AFgFaAVsBFgFZAVoBFgFYAVkBFgFXAVgBFgFWAVcBFgFVAVYBFgEXAVUBFwEYAVUBGAEZAVUBGQFUAVUBGgEbAVQBGwEcAVQBHAEdAVQBHQFTAVQBHgEfAVMBHwFSAVMBIQFSASABIgFSASEBIwFSASIBIwFRAVIBJAFRASMBJQFRASQBJgFRASUBDwI4AjkCDwI5Ag4CKAFQAScBEQI3AjgCEQI4AhACKgFPASkBQwBCAGcAQwBnAGYALAFOASsBUwJlAmYCUwJmAlICtwDaANsAtwDbALYALwFMAS4BkQKsAq0CkQKtApACMQFLATABGgIyAjMCGgIzAhkCGwIxAjICGwIyAhoCqgG7AbwBqgG8AakBNQFIATQBwgDTANQAwgDUAMEAwwDSANMAwwDTAMIAOAFGATcBXgBdAFEAXgBRAFAAOgFFATkBOwFFAToBOwFEAUUBPAFEATsBPQFEATwBPgFEAT0BPwFEAT4BPwFDAUQB6QAVAegA6gAVAekA6gAUARUB6wAUAeoA6wATARQB7AATAesA7AASARMB7QASAewA7QARARIB7gARAe0A7gAQAREB7wAQAe4ATQJsAm0CTQJtAkwCTgJrAmwCTgJsAk0CZgGBAYIBZgGCAWUBCwAKACUACwAlACQAUQJoAmkCUQJpAlACUgJnAmgCUgJoAlEC9QAJAQoBDgANACEADgAhACAAVAJkAmUCVAJlAlMCVQJjAmQCVQJkAlQCEQAQAB4AEQAeAB0A+QAEAQUB+gAEAfkA+gADAQQB+wADAfoA+wACAQMB/AACAfsA/AABAQIB/QABAfwA/QAAAQEB/gAAAf0A/gD/AAABQgFDAT8BPwFAAUEBPwFBAUIBigHOAc8BigHNAc4BigHMAc0BigHLAcwBigHKAcsBigHJAcoBigGLAckBiwGMAckBjAGNAckBjQHIAckBjgGPAcgBjwGQAcgBkAGRAcgBkQHHAcgBkgGTAccBkwHGAccBlQHGAZQBlgHGAZUBlwHGAZYBlwHFAcYBmAHFAZcBmQHFAZgBmgHFAZkBJwFQAVEBJwFRASYBnAHEAZsBKQFPAVABKQFQASgBngHDAZ0BEwI2AjcCEwI3AhICoAHCAZ8BFQI1AjYCFQI2AhQCFgI0AjUCFgI1AhUCowHAAaIBGAIzAjQCGAI0AhcCpQG/AaQB8QAOAQ8B8QAPAfAAvwDVANYAvwDWAL4AwADUANUAwADVAL8AqQG8AagBlwKoAqkClwKpApYCHwIuAi8CHwIvAh4CrAG6AasBfwCYAJkAfwCZAH4ArgG5Aa0BrwG5Aa4BrwG4AbkBsAG4Aa8BsQG4AbABsgG4AbEBswG4AbIBswG3AbgBXQGJAVwBXgGJAV0BXgGIAYkBXwGIAV4BXwGHAYgBYAGHAV8BYAGGAYcBYQGGAWABYQGFAYYBYgGFAWEBYgGEAYUBYwGEAWIB8AAPARAB8AAQAe8A2QH2AfcB2QH3AdgBCgAJACYACgAmACUAUAJpAmoCUAJqAk8CogHAAcEBogHBAaEBgACXAJgAgACYAH8AaQF9AX4BggCUAJUAggCVAIEAZABjAEgAZABIAEcAhACSAJMAhACTAIMA4QHtAe4B4QHuAeABbQF4AXkBbgF4AW0BbgF3AXgBbwF3AW4BbwF2AXcBcAF2AW8BcAF1AXYBcQF1AXABcQF0AXUBcgF0AXEBcgFzAXQBtgG3AbMBswG0AbUBswG1AbYB/gFCAkMC/gFBAkIC/gFAAkEC/gE/AkAC/gE+Aj8C/gE9Aj4C/gH/AT0C/wEAAj0CAAIBAj0CAQI8Aj0CAgIDAjwCAwIEAjwCBAIFAjwCBQI7AjwCBgIHAjsCBwI6AjsCCQI6AggCCgI6AgkCCwI6AgoCCwI5AjoCDAI5AgsCDQI5AgwCDgI5Ag0CswDcAN0AswDdALIAEAI4Ag8CtQDbANwAtQDcALQAEgI3AhECKwFOAU8BKwFPASoBFAI2AhMCZgBlAEUAZgBFAEQAugDYANkAugDZALkAFwI0AhYCMAFLAUwBMAFMAS8BGQIzAhgCkwKrAqwCkwKsApICbAF6AXsBbAF7AWsBNAFIAUkBNAFJATMBHQIwAhwC3wHvAfAB3wHwAd4BmAKnAqgCmAKoApcCIAIuAh8CrQG5AboBrQG6AawBIgItAiECIwItAiICIwIsAi0CJAIsAiMCJQIsAiQCJgIsAiUCJwIsAiYCJwIrAiwC0QH9AdAB0gH9AdEB0gH8Af0B0wH8AdIB0wH7AfwB1AH7AdMB1AH6AfsB1QH6AdQB1QH5AfoB1gH5AdUB1gH4AfkB1wH4AdYBCAAHACgACAAoACcAfQCaAJsAfQCbAHwAYgBhAEsAYgBLAEoAYQBgAEwAYQBMAEsADAALACQADAAkACMAaQF+AX8BaQF/AWgB3QHxAfIBagF8AX0BagF9AWkBgwCTAJQAgwCUAIIAvgDWANcAvgDXAL0A2AH3AfgB2AH4AdcB4QHsAe0B4gHsAeEB4gHrAewB4wHrAeIB4wHqAesB5AHqAeMB5AHpAeoB5QHpAeQB5QHoAekB5gHoAeUB5gHnAegBKgIrAicCJwIoAikCJwIpAioCdQK8Ar0CdQK7ArwCdQK6ArsCdQK5AroCdQK4ArkCdQK3ArgCdQJ2ArcCdgJ3ArcCdwJ4ArcCeAK1ArcCeQJ6ArUCegJ7ArUCfAJ+ArYCfQK0ArUCfwKAArQCgAKzArQCggKzAoECgwKzAoIChAKzAoMChAKyArMChQKyAoQChgKyAoUChwKyAoYCPwA+AGkAPwBpAGgAiQKxAogCnQHDAcQBnQHEAZwBiwKwAooCuQDZANoAuQDaALgAjQKvAowCLQFNAU4BLQFOASwBLgFMAU0BLgFNAS0BkAKtAo8CvADXANgAvADYALsAkgKsApECYwBiAEoAYwBKAEkApwG9Ab4BpwG+AaYBqAG8Ab0BqAG9AacBlgKpApUCNgFHAUgBNgFIATUBXwBeAE8AXwBPAE4AmQKnApgCIQItAi4CIQIuAiACmwKmApoCnAKmApsCnAKlAqYCnQKlApwCngKlAp0CnwKlAp4CoAKlAp8CoAKkAqUCRQJ0AkQCRwJ0AkUCRgJxAnMCSAJyAkcCSAJwAnICSQJwAkgCSQJvAnACSgJvAkkCSgJuAm8CSwJuAkoCSwJtAm4CTAJtAksCCQAIACcACQAnACYA2gH1AfYB2gH2AdkB8wAMAQ0B8wANAfIAaAF/AYABaAGAAWcB3QHyAfMB3QHzAdwBUgJmAmcC9gAIAQkB9gAJAfUAawF7AXwBawF8AWoB4AHuAe8B4AHvAd8B+QAFAQYB+QAGAfgAVgJhAmICVwJhAlYCVwJgAmECWAJgAlcCWAJfAmACWQJfAlgCWQJeAl8CWgJeAlkCWgJdAl4CWwJdAloCWwJcAl0CowKkAqACoAKhAqICoAKiAqMCgQCWAJcAgQCXAIAA"}]}""".encode()
            },
            "scene.gltf"
        )


class MeshProvider(abc.ABC):
    """
    This class is a base class for providing sources of meshes.
    """

    @staticmethod
    @abc.abstractmethod
    def id() -> str:
        pass

    @staticmethod
    @abc.abstractmethod
    def name() -> str:
        pass

    @abc.abstractmethod
    def find(
            self,
            parameters: typing.Dict[str, str],
            term: str,
            logger: BroomrocketLogger
    ) -> typing.List[LoadableMesh]:
        """
        You can use this method to search for a term and return a list of loadable meshes.
        :param parameters: The provider-specific parameters to use.
        :param term: The term or terms to search for.
        :param logger: A logger to write messages to.
        :return: A list of meshes that can be loaded.
        """
        pass


@dataclasses.dataclass
class NLPObjectToPlace:
    """
    This class holds an NLP-reference to an object to place. It also provides a count of objects, which indicates
    how many of the objects the user intended to place.
    """
    object: str
    count: int = 1

    def __eq__(self, other) -> bool:
        if not isinstance(other, NLPObjectToPlace):
            return False
        return self.object.lower() == other.object.lower() and self.count == other.count


@dataclasses.dataclass
class NLPSpatialReferenceObject:
    word: str
    plural: bool = False

    def __eq__(self, other) -> bool:
        if not isinstance(other, NLPSpatialReferenceObject):
            return False
        return self.word.lower() == other.word.lower() and self.plural == other.plural

    def __str__(self) -> str:
        return self.word


@dataclasses.dataclass
class NLPSpatialReference:
    """
    An NLP spatial reference describes the location of an item in relation to one or more reference objects. Optionally,
    it may also include the distance at which to place the objects and the units thereof.
    """
    location: str
    reference_objects: typing.List[NLPSpatialReferenceObject]
    distance: typing.Optional[int] = None
    units: typing.Optional[str] = None

    def __str__(self) -> str:
        return f"{self.location}: {self.reference_objects}"

    def __eq__(self, other) -> bool:
        if not isinstance(other, NLPSpatialReference):
            return False
        if self.location.lower() != other.location.lower():
            return False
        if len(self.reference_objects) != len(other.reference_objects):
            return False
        for ro in self.reference_objects:
            found = False
            for r in other.reference_objects:
                if ro == r:
                    found = True
            if not found:
                return False
        if self.distance != other.distance:
            return False
        if self.units != other.units:
            return False
        return True


@dataclasses.dataclass
class NLPParseResult:
    """
    The NLP parse result is the result of parsing a sentence with NLP. It contains an action to take (e.g. "place"),
    the objects to place, as well as the spatial references to place the objects in relation to.
    """
    action: str
    objects: typing.List[NLPObjectToPlace]
    spatial_references: typing.List[NLPSpatialReference] = dataclasses.field(default_factory=list)

    def __str__(self):
        return f"{self.objects} {'; '.join(map(lambda ref: str(ref), self.spatial_references))}"

    def __eq__(self, other) -> bool:
        if not isinstance(other, NLPParseResult):
            return False
        if other.action.lower() != self.action.lower():
            return False
        if len(other.objects) != len(self.objects):
            return False
        for obj in self.objects:
            found = False
            for o in other.objects:
                if obj == o:
                    found = True
                    break
            if not found:
                return False
        if len(other.spatial_references) != len(self.spatial_references):
            return False
        for sr in self.spatial_references:
            found = False
            for s in other.spatial_references:
                if sr == s:
                    found = True
            if not found:
                return False
        return True

    def __repr__(self):
        import json
        return json.dumps(dataclasses.asdict(self))


class NLPProvider(abc.ABC):
    """
    An NLP provider parses a sentence and returns an NLP result. It is guaranteed to always only receives one sentence.
    """

    @abc.abstractmethod
    def parse(self, sentence: str, logger: BroomrocketLogger) -> NLPParseResult:
        pass


class ReferenceFinder(abc.ABC):
    """
    A reference finder attempts to locate meshes described by the names supplied among the list of objects.
    """

    @abc.abstractmethod
    def find_reference_objects(
            self,
            names: typing.List[NLPSpatialReferenceObject],
            objects: typing.List[LoadedMesh]
    ) -> typing.List[LoadedMesh]:
        pass


class NamedReferenceFinder(ReferenceFinder):
    """
    This reference finder finds objects that contain the specified name in their object name.
    """

    def find_reference_objects(
            self,
            names: typing.List[NLPSpatialReferenceObject],
            objects: typing.List[LoadedMesh]
    ) -> typing.List[LoadedMesh]:
        for name in names:
            objects = list(filter(lambda obj: name.word in obj.name, objects))
            if len(objects) == 0:
                raise BroomrocketException(False, f"Cannot find reference object '{name.word}'")
            if name.plural and len(objects) < 2:
                raise BroomrocketException(False, f"Cannot find plural reference objects named '{name.word}'")
        return objects


@dataclasses.dataclass
class SpatialReference:
    """
    A spatial reference contains the objects required for a placement strategy.
    """
    reference_objects: typing.List[LoadedMesh]
    distance: typing.Optional[int] = None
    units: typing.Optional[str] = None

    _multipliers = {
        "nm": 0.000000001,
        "nanometer": 0.000000001,
        "nanometers": 0.000000001,
        "nanometre": 0.000000001,
        "nanometres": 0.000001,
        "micrometer": 0.000001,
        "micrometers": 0.000001,
        "micrometre": 0.000001,
        "micrometres": 0.000001,
        "mm": 0.001,
        "millimeter": 0.001,
        "millimeters": 0.001,
        "millimetre": 0.001,
        "millimetres": 0.001,
        "cm": 0.01,
        "centimeter": 0.01,
        "centimeters": 0.01,
        "centimetre": 0.01,
        "centimetres": 0.01,
        "dm": 0.1,
        "decimeter": 0.1,
        "decimeters": 0.1,
        "decimetre": 0.1,
        "decimetres": 0.1,
        "m": 1.0,
        "meter": 1.0,
        "meters": 1.0,
        "metre": 1.0,
        "metres": 1.0,
        "km": 1000.0,
        "kilometer": 1000.0,
        "kilometers": 1000.0,
        "kilometre": 1000.0,
        "kilometres": 1000.0,
        "ft": 0.3048,
        "foot": 0.3048,
        "feet": 0.3048,
        "in": 0.0254,
        "inch": 0.0254,
        "inches": 0.0254,
        "mi": 1609.34,
        "mile": 1609.34,
        "miles": 1609.34,
        "yard": 0.9144,
        "yards": 0.9144
    }

    def engine_units(self) -> float:
        if self.units is None:
            return 0
        try:
            return self.distance * self._multipliers[self.units]
        except KeyError:
            raise BroomrocketException(False,
                                f"Cannot find correct multiplier for distance unit {self.units}. Please state your distance units differently.")


class Axis(enum.Enum):
    X = "x"
    Y = "y"
    Z = "z"

    def __str__(self):
        return self.value


class Orientation(enum.Enum):
    """
    This enum contains an orientation in which to place multiple objects. X means that the items are lined up in the
    X direction, Y means the items are lined up in the Y direction.
    """
    X = "x"
    Y = "y"

    def get_axis(self) -> Axis:
        if self == Orientation.X:
            return Axis.X
        else:
            return Axis.Y

    def __str__(self):
        return self.value


class MinMax(enum.Enum):
    MIN = "min"
    MAX = "max"


@dataclasses.dataclass
class PlacementPreference:
    # Orientation describes on which axis to align the objects
    orientation: Orientation
    axis_minmax: typing.List[typing.Tuple[Axis, MinMax]]

    def __eq__(self, other):
        return self.orientation == other.orientation and \
            self.axis_minmax == other.axis_minmax


class PlacementStrategy(abc.ABC):
    """
    A placement strategy places target meshes in relation to reference objects based on a keyword (e.g. "behind").
    """

    @property
    @abc.abstractmethod
    def name(self) -> str:
        """
        This property returns the name of the strategy for debug logging
        """
        pass

    @property
    @abc.abstractmethod
    def keywords(self) -> typing.Optional[typing.Set[str]]:
        """
        This property returns the keywords that trigger this placement strategy (e.g. behind, under, etc). It may
        return None if the placement strategy handles cases where there are no explicit spatial references provided.
        """
        pass

    @abc.abstractmethod
    def calculate_placement_volume(
            self,
            target_meshes: typing.List[LoadedMesh],
            reference_objects: SpatialReference,
            all_objects: typing.List[LoadedMesh],
            logger: BroomrocketLogger
    ) -> typing.Tuple[Volume, PlacementPreference]:
        """
        This function calculates a possible placement volume where the meshes may be located. All volumes are
        intersected at the end and the intersection will be used to place the target meshes.
        """
        pass


# endregion

# region Placement strategies

class NoPlacementStrategy(PlacementStrategy):
    """
    This placement strategy handles the case where no additional spatial reference was provided. It allows placing the
    target objects at the center of the 3D space. When multiple objects are placed, they are placed along the Y axis.
    """

    @property
    def name(self) -> str:
        return "None"

    @property
    def keywords(self) -> typing.Optional[typing.Set[str]]:
        return None

    def calculate_placement_volume(
            self,
            target_meshes: typing.List[LoadedMesh],
            reference_objects: SpatialReference,
            all_objects: typing.List[LoadedMesh],
            logger: BroomrocketLogger
    ) -> typing.Tuple[Volume, PlacementPreference]:
        min_x = 0
        max_x = 0
        min_y = 0
        max_y = 0
        min_z = 0
        max_z = 00
        for target_mesh in target_meshes:
            mesh_min_x = target_mesh.size.min_x - target_mesh.translation.x
            mesh_max_x = target_mesh.size.max_x - target_mesh.translation.x
            mesh_min_y = target_mesh.size.min_y - target_mesh.translation.y
            mesh_max_y = target_mesh.size.max_y - target_mesh.translation.y
            mesh_min_z = target_mesh.size.min_z - target_mesh.translation.z
            mesh_max_z = target_mesh.size.max_z - target_mesh.translation.z
            min_x = min(mesh_min_x, min_x)
            max_x = max(mesh_max_x, max_x)
            min_y += mesh_min_y
            max_y += mesh_max_y
            max_z = max(mesh_max_z - mesh_min_z, max_z)

        v = Volume(
            min_x,
            max_x,
            min_y,
            max_y,
            min_z,
            max_z
        )
        logger.debug(
            f"Noop placement strategy: placing between ({v.min_x},{v.min_y},{v.min_z}) and ({v.max_x},{v.max_y},{v.max_z})"
        )
        return v, PlacementPreference(Orientation.Y, [])


class NoPlacementStrategyTest(unittest.TestCase):
    def test_single_mesh(self):
        strategy = NoPlacementStrategy()

        mesh = TestLoadedMesh(
            "test",
            Volume(
                -0.5,
                0.5,
                -0.5,
                0.5,
                -0.5,
                0.5
            ),
            Coordinate(0.0, 0.0, 0.0)
        )

        placement_volume, placement_preference = strategy.calculate_placement_volume(
            [mesh],
            SpatialReference([]),
            [mesh],
            PythonLogger()
        )

        self.assertEqual(Volume(-0.5, 0.5, -0.5, 0.5, 0.0, 1.0), placement_volume)
        self.assertEqual(Orientation.Y, placement_preference.orientation)
        self.assertEqual([], placement_preference.axis_minmax)

    def test_two_meshes(self):
        strategy = NoPlacementStrategy()

        mesh1 = TestLoadedMesh(
            "test1",
            Volume(
                -0.5,
                0.5,
                -0.5,
                0.5,
                -0.5,
                0.5
            ),
            Coordinate(0.0, 0.0, 0.0)
        )
        mesh2 = TestLoadedMesh(
            "test2",
            Volume(
                -0.5,
                0.5,
                -0.5,
                0.5,
                -0.5,
                0.5
            ),
            Coordinate(0.0, 0.0, 0.0)
        )

        placement_volume, placement_preference = strategy.calculate_placement_volume(
            [mesh1, mesh2],
            SpatialReference([]),
            [mesh1, mesh2],
            PythonLogger()
        )

        self.assertEqual(Volume(-0.5, 0.5, -1.0, 1.0, 0.0, 1.0), placement_volume)
        self.assertEqual(Orientation.Y, placement_preference.orientation)
        self.assertEqual([], placement_preference.axis_minmax)


class DirectionalPlacementStrategy(PlacementStrategy, abc.ABC):
    def _calculate_directional_placement_volume(
            self,
            target_axis: Axis,
            axis_orientation: int,
            target_meshes: typing.List[LoadedMesh],
            spatial_reference: SpatialReference,
            expand: bool,
            logger: BroomrocketLogger
    ) -> typing.Tuple[Volume, PlacementPreference]:
        space_requirement = 0
        space_requirement_z = 0
        if target_axis == "y":
            orientation = Orientation.X
        else:
            orientation = Orientation.Y
        for target_mesh in target_meshes:
            if target_axis == "y":
                # Align target meshes along the X axis
                space_requirement += target_mesh.size_x
            else:
                # Align target meshes along the Y axis
                space_requirement += target_mesh.size_y
            if space_requirement_z < target_mesh.size_z:
                space_requirement_z = target_mesh.size_z

        v = Volume(
            float("inf"),
            float("-inf"),
            float("inf"),
            float("-inf"),
            float("inf"),
            float("-inf")
        )
        if axis_orientation == -1:
            v.set_min_axis(target_axis, float("-inf"))
        else:
            v.set_max_axis(target_axis, float("inf"))

        # If multiple spatial references are presented (e.g. "behind the house and the barn"), we interpret that as
        # being behind the furthest one at the full width of both objects. We iterate over all reference objects and
        # obtain the coordinates.
        for reference_object in spatial_reference.reference_objects:
            reference_object_size = reference_object.get_size_submesh_fallback(f"loc:{self.name}")
            for axis in [Axis.X, Axis.Y, Axis.Z]:
                if axis == target_axis:
                    if axis_orientation == -1:
                        if reference_object_size.min_axis(axis) > v.max_axis(axis):
                            v.set_max_axis(axis, reference_object_size.min_axis(axis))
                    else:
                        if reference_object_size.max_axis(axis) < v.min_axis(axis):
                            v.set_min_axis(axis, reference_object_size.max_axis(axis))
                else:
                    if reference_object_size.min_axis(axis) < v.min_axis(axis):
                        v.set_min_axis(axis, reference_object_size.min_axis(axis))
                    if reference_object_size.max_axis(axis) > v.max_axis(axis):
                        v.set_max_axis(axis, reference_object_size.max_axis(axis))
        if expand:
            # Check if we need to expand the placement volume
            extra_space_orientation = space_requirement - v.size_axis(str(orientation))
            if extra_space_orientation > 0:
                v.set_min_axis(orientation.get_axis(), v.min_axis(orientation.get_axis()) - extra_space_orientation / 2)
                v.set_max_axis(orientation.get_axis(), v.max_axis(orientation.get_axis()) + extra_space_orientation / 2)
            extra_space_z = space_requirement_z - v.size_z
            if extra_space_z > 0:
                v.max_z = v.max_z + extra_space_z

        minmax = MinMax.MIN
        if axis_orientation == -1:
            minmax = MinMax.MAX
        return v, PlacementPreference(
            orientation,
            [
                (target_axis, minmax)
            ]
        )


class BehindPlacementStrategy(DirectionalPlacementStrategy):
    """
    This placement strategy places an object on a lesser X coordinate than the reference object(s).
    """

    @property
    def name(self) -> str:
        return "behind"

    @property
    def keywords(self) -> typing.Optional[typing.Set[str]]:
        return {"behind"}

    def calculate_placement_volume(
            self,
            target_meshes: typing.List[LoadedMesh],
            spatial_reference: SpatialReference,
            all_objects: typing.List[LoadedMesh],
            logger: BroomrocketLogger
    ) -> typing.Tuple[Volume, PlacementPreference]:
        return self._calculate_directional_placement_volume(
            Axis.X,
            -1,
            target_meshes,
            spatial_reference,
            True,
            logger
        )


class DirectionalPlacementStrategyTest(unittest.TestCase, abc.ABC):
    _test_cases: typing.Dict[str, typing.Tuple[
        typing.List[TestLoadedMesh],
        typing.List[TestLoadedMesh],
        Volume,
        Orientation,
        typing.List[typing.Tuple[Axis, MinMax]]
    ]]

    @abc.abstractmethod
    def _create_strategy(self) -> PlacementStrategy:
        pass

    def test_data(self):
        strategy = self._create_strategy()
        for name, data in self._test_cases.items():
            with self.subTest(name=name):
                placement_volume, placement_preference = strategy.calculate_placement_volume(
                    data[0],
                    SpatialReference(data[1]),
                    data[0] + data[1],
                    PythonLogger()
                )
                self.assertEqual(data[2], placement_volume)
                self.assertEqual(data[3], placement_preference.orientation)
                self.assertEqual(data[4], placement_preference.axis_minmax)


class BehindPlacementStrategyTest(DirectionalPlacementStrategyTest):
    def _create_strategy(self) -> PlacementStrategy:
        return BehindPlacementStrategy()

    _test_cases = {
        "single": (
            [
                TestLoadedMesh("target", Volume(-0.5, 0.5, -0.5, 0.5, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0))
            ],
            [
                TestLoadedMesh("ref", Volume(-0.5, 0.5, -0.5, 0.5, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0))
            ],
            Volume(float("-inf"), -0.5, -0.5, 0.5, -0.5, 0.5),
            Orientation.Y,
            [(Axis.X, MinMax.MAX)]
        ),
        "bottom": (
            [
                TestLoadedMesh("target", Volume(-0.5, 0.5, -0.5, 0.5, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0))
            ],
            [
                TestLoadedMesh("ref", Volume(-0.5, 0.5, -0.5, 0.5, -0.5, 1.0), Coordinate(0.0, 0.0, 0.0))
            ],
            Volume(float("-inf"), -0.5, -0.5, 0.5, -0.5, 1.0),
            Orientation.Y,
            [(Axis.X, MinMax.MAX)],
        ),
        "double-refs": (
            [
                TestLoadedMesh("target", Volume(-0.5, 0.5, -0.5, 0.5, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0))
            ],
            [
                TestLoadedMesh("ref1", Volume(-0.5, 0.5, -1.0, 0.0, -0.5, 1.0), Coordinate(0.0, 0.0, 0.0)),
                TestLoadedMesh("ref2", Volume(-0.5, 0.5, 0.0, 1.0, -0.5, 1.0), Coordinate(0.0, 0.0, 0.0))
            ],
            Volume(float("-inf"), -0.5, -1.0, 1.0, -0.5, 1.0),
            Orientation.Y,
            [(Axis.X, MinMax.MAX)],
        ),
        "double-targets": (
            [
                TestLoadedMesh("target1", Volume(-0.5, 0.5, -0.5, 0.5, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0)),
                TestLoadedMesh("target2", Volume(-0.5, 0.5, -0.5, 0.5, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0))
            ],
            [
                TestLoadedMesh("ref", Volume(-0.5, 0.5, -0.5, 0.5, -0.5, 1.0), Coordinate(0.0, 0.0, 0.0))
            ],
            Volume(float("-inf"), -0.5, -1.0, 1.0, -0.5, 1.0),
            Orientation.Y,
            [(Axis.X, MinMax.MAX)],
        )
    }


class FrontPlacementStrategy(DirectionalPlacementStrategy):
    """
    This placement strategy places an object on a higher X coordinate than the reference object(s).
    """

    @property
    def name(self) -> str:
        return "front"

    @property
    def keywords(self) -> typing.Optional[typing.Set[str]]:
        return {"front", "in front of", "before", "in front"}

    def calculate_placement_volume(
            self,
            target_meshes: typing.List[LoadedMesh],
            spatial_reference: SpatialReference,
            all_objects: typing.List[LoadedMesh],
            logger: BroomrocketLogger
    ) -> typing.Tuple[Volume, PlacementPreference]:
        return self._calculate_directional_placement_volume(
            Axis.X,
            1,
            target_meshes,
            spatial_reference,
            True,
            logger
        )


class FrontPlacementStrategyTest(DirectionalPlacementStrategyTest):
    def _create_strategy(self) -> PlacementStrategy:
        return FrontPlacementStrategy()

    _test_cases = {
        "single": (
            [
                TestLoadedMesh("target", Volume(-0.5, 0.5, -0.5, 0.5, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0))
            ],
            [
                TestLoadedMesh("ref", Volume(-0.5, 0.5, -0.5, 0.5, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0))
            ],
            Volume(0.5, float("inf"), -0.5, 0.5, -0.5, 0.5),
            Orientation.Y,
            [(Axis.X, MinMax.MIN)]
        ),
        "bottom": (
            [
                TestLoadedMesh("target", Volume(-0.5, 0.5, -0.5, 0.5, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0))
            ],
            [
                TestLoadedMesh("ref", Volume(-0.5, 0.5, -0.5, 0.5, -0.5, 1.0), Coordinate(0.0, 0.0, 0.0))
            ],
            Volume(0.5, float("inf"), -0.5, 0.5, -0.5, 1.0),
            Orientation.Y,
            [(Axis.X, MinMax.MIN)],
        ),
        "double-refs": (
            [
                TestLoadedMesh("target", Volume(-0.5, 0.5, -0.5, 0.5, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0))
            ],
            [
                TestLoadedMesh("ref1", Volume(-0.5, 0.5, -1.0, 0.0, -0.5, 1.0), Coordinate(0.0, 0.0, 0.0)),
                TestLoadedMesh("ref2", Volume(-0.5, 0.5, 0.0, 1.0, -0.5, 1.0), Coordinate(0.0, 0.0, 0.0))
            ],
            Volume(0.5, float("inf"), -1.0, 1.0, -0.5, 1.0),
            Orientation.Y,
            [(Axis.X, MinMax.MIN)],
        ),
        "double-targets": (
            [
                TestLoadedMesh("target1", Volume(-0.5, 0.5, -0.5, 0.5, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0)),
                TestLoadedMesh("target2", Volume(-0.5, 0.5, -0.5, 0.5, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0))
            ],
            [
                TestLoadedMesh("ref", Volume(-0.5, 0.5, -0.5, 0.5, -0.5, 1.0), Coordinate(0.0, 0.0, 0.0))
            ],
            Volume(0.5, float("inf"), -1.0, 1.0, -0.5, 1.0),
            Orientation.Y,
            [(Axis.X, MinMax.MIN)],
        )
    }


class LeftPlacementStrategy(DirectionalPlacementStrategy):
    """
    This placement strategy places an object on a lower Y coordinate than the reference object(s).
    """

    @property
    def name(self) -> str:
        return "left"

    @property
    def keywords(self) -> typing.Optional[typing.Set[str]]:
        return {"left", "to the left of", "left of", "to the left", "backboard"}

    def calculate_placement_volume(
            self,
            target_meshes: typing.List[LoadedMesh],
            spatial_reference: SpatialReference,
            all_objects: typing.List[LoadedMesh],
            logger: BroomrocketLogger
    ) -> typing.Tuple[Volume, PlacementPreference]:
        return self._calculate_directional_placement_volume(
            Axis.Y,
            -1,
            target_meshes,
            spatial_reference,
            True,
            logger
        )


class LeftPlacementStrategyTest(DirectionalPlacementStrategyTest):
    def _create_strategy(self) -> PlacementStrategy:
        return LeftPlacementStrategy()

    _test_cases = {
        "single": (
            [
                TestLoadedMesh("target", Volume(-0.5, 0.5, -0.5, 0.5, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0))
            ],
            [
                TestLoadedMesh("ref", Volume(-0.5, 0.5, -0.5, 0.5, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0))
            ],
            Volume(-0.5, 0.5, float("-inf"), -0.5, -0.5, 0.5),
            Orientation.Y,
            [(Axis.Y, MinMax.MAX)]
        ),
        "bottom": (
            [
                TestLoadedMesh("target", Volume(-0.5, 0.5, -0.5, 0.5, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0))
            ],
            [
                TestLoadedMesh("ref", Volume(-0.5, 0.5, -0.5, 0.5, -0.5, 1.0), Coordinate(0.0, 0.0, 0.0))
            ],
            Volume(-0.5, 0.5, float("-inf"), -0.5, -0.5, 1.0),
            Orientation.Y,
            [(Axis.Y, MinMax.MAX)]
        ),
        "double-refs": (
            [
                TestLoadedMesh("target", Volume(-0.5, 0.5, -0.5, 0.5, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0))
            ],
            [
                TestLoadedMesh("ref1", Volume(0.0, 1.0, -0.5, 0.5, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0)),
                TestLoadedMesh("ref2", Volume(-1.0, 0.0, -0.5, 0.5, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0))
            ],
            Volume(-1.0, 1.0, float("-inf"), -0.5, -0.5, 0.5),
            Orientation.Y,
            [(Axis.Y, MinMax.MAX)]
        ),
        "double-targets": (
            [
                TestLoadedMesh("target1", Volume(-0.5, 0.5, -0.5, 0.5, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0)),
                TestLoadedMesh("target2", Volume(-0.5, 0.5, -0.5, 0.5, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0))
            ],
            [
                TestLoadedMesh("ref", Volume(-0.5, 0.5, -0.5, 0.5, -0.5, 1.0), Coordinate(0.0, 0.0, 0.0))
            ],
            Volume(-0.5, 0.5, float("-inf"), -0.5, -0.5, 1.0),
            Orientation.Y,
            [(Axis.Y, MinMax.MAX)]
        )
    }


class RightPlacementStrategy(DirectionalPlacementStrategy):
    """
    This placement strategy places an object on a higher Y coordinate than the reference object(s).
    """

    @property
    def name(self) -> str:
        return "right"

    @property
    def keywords(self) -> typing.Optional[typing.Set[str]]:
        return {"right", "to the right of", "right of", "to the right", "starboard", "steuerboard"}

    def calculate_placement_volume(
            self,
            target_meshes: typing.List[LoadedMesh],
            spatial_reference: SpatialReference,
            all_objects: typing.List[LoadedMesh],
            logger: BroomrocketLogger
    ) -> typing.Tuple[Volume, PlacementPreference]:
        return self._calculate_directional_placement_volume(
            Axis.Y,
            1,
            target_meshes,
            spatial_reference,
            True,
            logger
        )


class RightPlacementStrategyTest(DirectionalPlacementStrategyTest):
    def _create_strategy(self) -> PlacementStrategy:
        return RightPlacementStrategy()

    _test_cases = {
        "single": (
            [
                TestLoadedMesh("target", Volume(-0.5, 0.5, -0.5, 0.5, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0))
            ],
            [
                TestLoadedMesh("ref", Volume(-0.5, 0.5, -0.5, 0.5, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0))
            ],
            Volume(-0.5, 0.5, 0.5, float("inf"), -0.5, 0.5),
            Orientation.Y,
            [(Axis.Y, MinMax.MIN)]
        ),
        "bottom": (
            [
                TestLoadedMesh("target", Volume(-0.5, 0.5, -0.5, 0.5, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0))
            ],
            [
                TestLoadedMesh("ref", Volume(-0.5, 0.5, -0.5, 0.5, -0.5, 1.0), Coordinate(0.0, 0.0, 0.0))
            ],
            Volume(-0.5, 0.5, 0.5, float("inf"), -0.5, 1.0),
            Orientation.Y,
            [(Axis.Y, MinMax.MIN)]
        ),
        "double-refs": (
            [
                TestLoadedMesh("target", Volume(-0.5, 0.5, -0.5, 0.5, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0))
            ],
            [
                TestLoadedMesh("ref1", Volume(0.0, 1.0, -0.5, 0.5, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0)),
                TestLoadedMesh("ref2", Volume(-1.0, 0.0, -0.5, 0.5, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0))
            ],
            Volume(-1.0, 1.0, 0.5, float("inf"), -0.5, 0.5),
            Orientation.Y,
            [(Axis.Y, MinMax.MIN)]
        ),
        "double-targets": (
            [
                TestLoadedMesh("target1", Volume(-0.5, 0.5, -0.5, 0.5, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0)),
                TestLoadedMesh("target2", Volume(-0.5, 0.5, -0.5, 0.5, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0))
            ],
            [
                TestLoadedMesh("ref", Volume(-0.5, 0.5, -0.5, 0.5, -0.5, 1.0), Coordinate(0.0, 0.0, 0.0))
            ],
            Volume(-0.5, 0.5, 0.5, float("inf"), -0.5, 1.0),
            Orientation.Y,
            [(Axis.Y, MinMax.MIN)]
        )
    }


class OnPlacementStrategy(DirectionalPlacementStrategy):
    """
    This placement strategy places an object on a higher z coordinate than the reference object(s).
    """

    @property
    def name(self) -> str:
        return "on"

    @property
    def keywords(self) -> typing.Optional[typing.Set[str]]:
        return {"on"}

    def calculate_placement_volume(
            self,
            target_meshes: typing.List[LoadedMesh],
            spatial_reference: SpatialReference,
            all_objects: typing.List[LoadedMesh],
            logger: BroomrocketLogger
    ) -> typing.Tuple[Volume, PlacementPreference]:
        return self._calculate_directional_placement_volume(
            Axis.Z,
            1,
            target_meshes,
            spatial_reference,
            False,
            logger
        )


class OnPlacementStrategyTest(DirectionalPlacementStrategyTest):
    def _create_strategy(self) -> PlacementStrategy:
        return OnPlacementStrategy()

    _test_cases = {
        "single": (
            [
                TestLoadedMesh("target", Volume(-0.5, 0.5, -0.5, 0.5, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0))
            ],
            [
                TestLoadedMesh("ref", Volume(-0.5, 0.5, -0.5, 0.5, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0))
            ],
            Volume(-0.5, 0.5, -0.5, 0.5, 0.5, float("inf")),
            Orientation.Y,
            [(Axis.Z, MinMax.MIN)]
        ),
        "double-refs": (
            [
                TestLoadedMesh("target", Volume(-0.5, 0.5, -0.5, 0.5, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0))
            ],
            [
                TestLoadedMesh("ref1", Volume(-0.5, 0.5, -1.0, 0.0, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0)),
                TestLoadedMesh("ref2", Volume(-0.5, 0.5, 0.0, 1.0, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0))
            ],
            Volume(-0.5, 0.5, -1.0, 1.0, 0.5, float("inf")),
            Orientation.Y,
            [(Axis.Z, MinMax.MIN)]
        ),
        "double-targets": (
            [
                TestLoadedMesh("target1", Volume(-0.5, 0.5, -0.5, 0.5, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0)),
                TestLoadedMesh("target2", Volume(-0.5, 0.5, -0.5, 0.5, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0))
            ],
            [
                TestLoadedMesh("ref", Volume(-1.0, 1.0, -1.0, 1.0, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0))
            ],
            Volume(-1.0, 1.0, -1.0, 1.0, 0.5, float("inf")),
            Orientation.Y,
            [(Axis.Z, MinMax.MIN)]
        )
    }


class AbovePlacementStrategy(DirectionalPlacementStrategy):
    """
    This placement strategy places an object on a higher z coordinate than the reference object(s).
    """

    @property
    def name(self) -> str:
        return "above"

    @property
    def keywords(self) -> typing.Optional[typing.Set[str]]:
        return {"above"}

    def calculate_placement_volume(
            self,
            target_meshes: typing.List[LoadedMesh],
            spatial_reference: SpatialReference,
            all_objects: typing.List[LoadedMesh],
            logger: BroomrocketLogger
    ) -> typing.Tuple[Volume, PlacementPreference]:
        return self._calculate_directional_placement_volume(
            Axis.Z,
            1,
            target_meshes,
            spatial_reference,
            True,
            logger
        )


class AbovePlacementStrategyTest(DirectionalPlacementStrategyTest):
    def _create_strategy(self) -> PlacementStrategy:
        return AbovePlacementStrategy()

    _test_cases = {
        "single": (
            [
                TestLoadedMesh("target", Volume(-0.5, 0.5, -0.5, 0.5, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0))
            ],
            [
                TestLoadedMesh("ref", Volume(-0.5, 0.5, -0.5, 0.5, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0))
            ],
            Volume(-0.5, 0.5, -0.5, 0.5, 0.5, float("inf")),
            Orientation.Y,
            [(Axis.Z, MinMax.MIN)]
        ),
        "double-refs": (
            [
                TestLoadedMesh("target", Volume(-0.5, 0.5, -0.5, 0.5, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0))
            ],
            [
                TestLoadedMesh("ref1", Volume(-0.5, 0.5, -1.0, 0.0, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0)),
                TestLoadedMesh("ref2", Volume(-0.5, 0.5, 0.0, 1.0, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0))
            ],
            Volume(-0.5, 0.5, -1.0, 1.0, 0.5, float("inf")),
            Orientation.Y,
            [(Axis.Z, MinMax.MIN)]
        ),
        "double-targets": (
            [
                TestLoadedMesh("target1", Volume(-0.5, 0.5, -0.5, 0.5, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0)),
                TestLoadedMesh("target2", Volume(-0.5, 0.5, -0.5, 0.5, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0))
            ],
            [
                TestLoadedMesh("ref", Volume(-1.0, 1.0, -1.0, 1.0, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0))
            ],
            Volume(-1.0, 1.0, -1.0, 1.0, 0.5, float("inf")),
            Orientation.Y,
            [(Axis.Z, MinMax.MIN)]
        )
    }


class UnderPlacementStrategy(DirectionalPlacementStrategy):
    """
    This placement strategy places an object on a lower z coordinate than the reference object(s).
    """

    @property
    def name(self) -> str:
        return "under"

    @property
    def keywords(self) -> typing.Optional[typing.Set[str]]:
        return {"under", "beneath", "below"}

    def calculate_placement_volume(
            self,
            target_meshes: typing.List[LoadedMesh],
            spatial_reference: SpatialReference,
            all_objects: typing.List[LoadedMesh],
            logger: BroomrocketLogger
    ) -> typing.Tuple[Volume, PlacementPreference]:
        return self._calculate_directional_placement_volume(
            Axis.Z,
            -1,
            target_meshes,
            spatial_reference,
            True,
            logger
        )


class UnderPlacementStrategyTest(DirectionalPlacementStrategyTest):
    def _create_strategy(self) -> PlacementStrategy:
        return UnderPlacementStrategy()

    _test_cases = {
        "single": (
            [
                TestLoadedMesh("target", Volume(-0.5, 0.5, -0.5, 0.5, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0))
            ],
            [
                TestLoadedMesh("ref", Volume(-0.5, 0.5, -0.5, 0.5, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0))
            ],
            Volume(-0.5, 0.5, -0.5, 0.5, float("-inf"), -0.5),
            Orientation.Y,
            [(Axis.Z, MinMax.MAX)]
        ),
        "double-refs": (
            [
                TestLoadedMesh("target", Volume(-0.5, 0.5, -0.5, 0.5, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0))
            ],
            [
                TestLoadedMesh("ref1", Volume(-0.5, 0.5, -1.0, 0.0, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0)),
                TestLoadedMesh("ref2", Volume(-0.5, 0.5, 0.0, 1.0, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0))
            ],
            Volume(-0.5, 0.5, -1.0, 1.0, float("-inf"), -0.5),
            Orientation.Y,
            [(Axis.Z, MinMax.MAX)]
        ),
        "double-targets": (
            [
                TestLoadedMesh("target1", Volume(-0.5, 0.5, -0.5, 0.5, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0)),
                TestLoadedMesh("target2", Volume(-0.5, 0.5, -0.5, 0.5, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0))
            ],
            [
                TestLoadedMesh("ref", Volume(-1.0, 1.0, -1.0, 1.0, -0.5, 0.5), Coordinate(0.0, 0.0, 0.0))
            ],
            Volume(-1.0, 1.0, -1.0, 1.0, float("-inf"), -0.5),
            Orientation.Y,
            [(Axis.Z, MinMax.MAX)]
        )
    }


# endregion

# region Spacy NLP provider

class SpaCyNLPProvider(NLPProvider):
    """
    This NLP provider uses Spacy version 3.5.3 with the en_core_web_sm version 3.5.0 language model to parse
    sentences.

    Note: the implementation contains several workarounds for these specific versions and version upgrades should be
    tested. An appropriate unit test case is provided below.
    """

    def __init__(self):
        self._nlp = spacy.load("en_core_web_sm")

    def _find_children(self, token, kind: str) -> typing.List:
        result = []
        for token in token.lefts:
            if token.dep_ == kind:
                result.append(token)
        for token in token.rights:
            if token.dep_ == kind:
                result.append(token)
        return result

    _numberwords = {
        "zero": 0,
        "one": 1,
        "two": 2,
        "three": 3,
        "four": 4,
        "five": 5,
        "six": 6,
        "seven": 7,
        "eight": 8,
        "nine": 9,
        "ten": 10,
        "eleven": 11,
        "twelve": 12,
        "thirteen": 13,
        "fourteen": 14,
        "fiveteen": 15,
        "sixteen": 16,
        "seventeen": 17,
        "eighteen": 18,
        "nineteen": 19,
        "twenty": 20,
        "thirty": 30,
        "fourty": 40,
        "fifty": 50,
        "sixty": 60,
        "seventy": 70,
        "eighty": 80,
        "ninety": 90
    }
    _multipliers = {
        "hundred": 100,
        "thousand": 1000,
        "million": 1000000,
        "billion": 1000000000,
    }

    def _convert_number(self, num: str, prevnum: int) -> typing.Tuple[int, bool]:
        # TODO support five hundred thousand
        try:
            return int(num), False
        except ValueError:
            pass

        num = num.replace('-', '').replace(' ', '')
        sum = 0
        failed = False
        while len(num) > 0:
            found_number = None
            for numword in self._numberwords:
                if num.startswith(numword):
                    sum += self._numberwords[numword]
                    num = num.removeprefix(numword)
                    found_number = True
                    break
            if not found_number:
                failed = True
                break
        if not failed:
            return sum, False

        for numword in self._multipliers:
            if num == numword:
                if prevnum == 0:
                    return self._multipliers[numword], True
                return prevnum * self._multipliers[numword], True

    def parse(self, sentence: str, logger: BroomrocketLogger) -> NLPParseResult:
        import spacy.tokens.token
        @dataclasses.dataclass
        class _Token:
            token: spacy.tokens.token.Token
            text: str
            plural: bool

            def __init__(self, token: spacy.tokens.token.Token):
                self.token = token
                self.text = token.lemma_
                self.plural = token.lemma_ != str(token)

            def __str__(self):
                return self.text

            def to_spatial_reference(self) -> NLPSpatialReferenceObject:
                return NLPSpatialReferenceObject(self.text, self.plural)

        doc = self._nlp(sentence)
        action = ""
        objects_to_place = []
        spatial_references: typing.List[NLPSpatialReference] = []
        current_spatial_references: typing.List[_Token] = []
        noun_buffer = []

        last_key = None
        conjunction = False
        noun_found = False
        current_spatial_reference_word = None
        prev_adv = None
        distance_quantity = None
        distance_denomination = None
        next_distance_quantity = None
        next_distance_denomination = None

        def push_spatial_reference():
            """
            This function takes the collected spatial references and their word and pushes them into the spatial
            references list. This function gets called whenever a new spatial reference word is discovered.
            """
            if current_spatial_reference_word is not None and len(current_spatial_references) > 0:
                # Push to the spatial_references
                spatial_references.append(NLPSpatialReference(
                    str(current_spatial_reference_word),
                    list(map(lambda obj: obj.to_spatial_reference(), current_spatial_references)),
                    distance_quantity,
                    distance_denomination
                ))

        sum = 0
        prevnum = 0
        i = -1
        doc_list = list(doc)

        for token in doc_list:
            i += 1
            if token.pos_ == "VERB" or (token.pos_ == "NOUN" and i == 0 and token.norm_ == "place"):
                # Verbs are always treated as actions to take. There are edge cases that contain multiple verbs, such as
                # "There are 10 trees surrounding the house", which are not handled.
                action = str(token)
                last_key = "VERB"
                push_spatial_reference()
                distance_quantity = next_distance_quantity
                distance_denomination = next_distance_denomination
                next_distance_quantity = None
                next_distance_denomination = None
                current_spatial_reference_word = None
                current_spatial_references = []
                for noun in noun_buffer:
                    objects_to_place.append(NLPObjectToPlace(noun.text))
                noun_buffer: typing.List[_Token] = []
                noun_found = False
            elif token.pos_ == "NUM":
                # Numeric references happen when distances are specified, such as "3 meters behind ...". Since the
                # numeric reference is always before the spatial reference, a shifting buffer is used.
                parsed_number, multiplier = self._convert_number(str(token), prevnum)
                if multiplier:
                    sum += parsed_number
                else:
                    prevnum = parsed_number
            elif token.pos_ == "ADV":
                # Adverbs are handled in conjunction with adpositions, such as "next to".
                prev_adv = str(token)
            elif token.pos_ == "ADP":
                last_key = "ADP"

                special_case = False
                if str(token) == "of":
                    if current_spatial_reference_word in ["in", "at"]:
                        # Special case: "in front of"
                        # Here both "in" and "of" are recognized as ADPs and we need to use the "front" noun as a
                        # spatial reference word since it will work best with the 3D placement algorithm.
                        current_spatial_reference_word = str(
                            current_spatial_references[len(current_spatial_references) - 1])
                        current_spatial_references = []
                        special_case = True
                    elif len(noun_buffer) != 0:
                        # Special case: "right of"
                        # This special case works around a Spacy bug, which incorrectly classifies "right" in "right of"
                        # as a noun. We take that noun and use it as a spatial reference word. See code in the noun
                        # handling below.
                        current_spatial_reference_word = noun_buffer[0]
                        special_case = True
                    elif current_spatial_reference_word == "to":
                        # Special case: "to the left of"
                        # In this case the previous spatial reference word is "to", while the current is "of. We take
                        # the noun "left" as a spatial reference as it will work best with the 3D placement algorithm.
                        # This is not a special
                        current_spatial_reference_word = None
                        token = current_spatial_references[0].token
                        current_spatial_references = []
                if not special_case:
                    push_spatial_reference()
                    distance_quantity = next_distance_quantity
                    distance_denomination = next_distance_denomination
                    next_distance_quantity = None
                    next_distance_denomination = None
                    current_spatial_references = []

                    current_spatial_reference_word = prev_adv + " " + str(token) if prev_adv is not None else str(token)
                    for noun in noun_buffer:
                        current_spatial_references.append(noun)
                noun_buffer = []
                noun_found = False
                prev_adv = None
            elif token.pos_ == "CCONJ":
                # Conjunctions are explicitly marked to allow collecting more nouns into the noun buffer.
                conjunction = True
            elif token.pos_ == "NOUN":
                # Nouns are collected and attached either to the previous adposition or verb, or collected into a
                # noun buffer and added when the next adposition or verb is encountered. The nouns are collected as
                # long as there is a conjunction between them. If two consecutive nouns are encountered without a
                # conjunction, but the nouns are compound nouns (e.g. flower pot), they are merged into one noun
                # delimited with a space. Finally, when two consecutive nouns are located without conjunctions and
                # without being compound nouns, they are checked if they are quantity types (e.g. meters) and are
                # recorded as distance denominations. If none of the above applies, the noun collection is interrupted
                # and a new noun buffer is started.
                compound = False
                of_case = False
                if noun_found and not conjunction:
                    for left in token.lefts:
                        if left.dep_ == "compound":
                            if len(doc_list) > i + 1 and str(doc_list[i + 1]) == "of":
                                # Spacy incorrectly classifies "right" in "right of" as a compound with a previous noun.
                                of_case = True
                                noun_buffer.append(_Token(token))
                                push_spatial_reference()
                                distance_quantity = next_distance_quantity
                                distance_denomination = next_distance_denomination
                                next_distance_quantity = None
                                next_distance_denomination = None
                                current_spatial_references = []
                            else:
                                compound = True
                            break
                    if of_case:
                        continue
                    if not compound:
                        if token.ent_type_ == "QUANTITY":
                            sum = prevnum + sum
                            next_distance_quantity = sum if sum > 0 else 1
                            next_distance_denomination = str(token.lemma_)
                            sum = 0
                            prevnum = 0
                            continue
                        else:
                            raise BroomrocketException(False, "Could not understand your sentence, please try to rephrase it.")
                noun_found = True
                if last_key is None:
                    if compound:
                        noun_buffer[len(noun_buffer) - 1] += " " + str(token)
                    else:
                        noun_buffer.append(_Token(token))
                elif last_key == "ADP":
                    if compound:
                        current_spatial_references[len(current_spatial_references) - 1].text += " " + str(token.lemma_)
                        current_spatial_references[len(current_spatial_references) - 1].plural = \
                            (token.lemma_ != str(token))
                    else:
                        current_spatial_references.append(_Token(token))
                elif last_key == "VERB":
                    if compound:
                        objects_to_place[len(objects_to_place) - 1].object += " " + str(token.lemma_)
                    else:
                        sum = prevnum + sum
                        sum = sum if sum > 0 else 1
                        objects_to_place.append(NLPObjectToPlace(str(token.lemma_), sum))
                        prevnum = 0
                        sum = 0
        push_spatial_reference()

        return NLPParseResult(
            action,
            objects_to_place,
            spatial_references
        )


class SpacyNLPProviderUnitTest(unittest.TestCase):
    """
    This unit test class tests that the Spacy NLP provider works correctly by providing sample sentences and testing
    the output against a pre-recorded result.
    """

    def test_sentences(self):
        test_sentences = {
            "Place 2 houses": NLPParseResult(
               "place",
               [NLPObjectToPlace("house", count=2)],
               []
            ),
            "Add a flower pot 5 meters behind the pools": NLPParseResult(
                "add",
                [NLPObjectToPlace("flower pot")],
                [
                    NLPSpatialReference(
                        reference_objects=[NLPSpatialReferenceObject("pool", True)],
                        location="behind",
                        distance=5,
                        units="meter"
                    )
                ]
            ),
            "Make 2 houses": NLPParseResult(
                "make",
                [NLPObjectToPlace("house", count=2)],
                []
            ),
            "Add a pool 5 meters behind the house": NLPParseResult(
                "add",
                [NLPObjectToPlace("pool")],
                [
                    NLPSpatialReference(
                        reference_objects=[NLPSpatialReferenceObject("house")],
                        location="behind",
                        distance=5,
                        units="meter"
                    )
                ]
            ),
            "Add two flower pots in front of the house": NLPParseResult(
                "add",
                [NLPObjectToPlace("flower pot", 2)],
                [
                    NLPSpatialReference(
                        reference_objects=[NLPSpatialReferenceObject("house")],
                        location="front"
                    )
                ]
            ),
            "There is a car and a ball to the left of the house in front of the tree": NLPParseResult(
                "is",
                [NLPObjectToPlace("car"), NLPObjectToPlace("ball")],
                [
                    NLPSpatialReference(
                        reference_objects=[NLPSpatialReferenceObject("house")],
                        location="left"
                    ),
                    NLPSpatialReference(
                        reference_objects=[NLPSpatialReferenceObject("tree")],
                        location="front"
                    )
                ]
            ),
            "There is a mountain in the background": NLPParseResult(
                "is",
                [NLPObjectToPlace("mountain")],
                [
                    NLPSpatialReference(
                        reference_objects=[NLPSpatialReferenceObject("background")],
                        location="in",
                    )
                ]
            ),
            "There is a billboard in the front": NLPParseResult(
                "is",
                [NLPObjectToPlace("billboard")],
                [
                    NLPSpatialReference(
                        reference_objects=[NLPSpatialReferenceObject("front")],
                        location="in",
                    )
                ]
            ),
            "There is a swing right of the house and the garden": NLPParseResult(
                "is",
                [NLPObjectToPlace("swing")],
                [
                    NLPSpatialReference(
                        reference_objects=[NLPSpatialReferenceObject("house"), NLPSpatialReferenceObject("garden")],
                        location="right"
                    )
                ]
            ),
            "Place a lawnmower next to the house": NLPParseResult(
                "place",
                [NLPObjectToPlace("lawnmower")],
                [
                    NLPSpatialReference(
                        reference_objects=[NLPSpatialReferenceObject("house")],
                        location="next to"
                    )
                ]
            ),
            "Place a bench on the porch in front of the door": NLPParseResult(
                "place",
                [NLPObjectToPlace("bench")],
                [
                    NLPSpatialReference(
                        reference_objects=[NLPSpatialReferenceObject("porch")],
                        location="on"
                    ),
                    NLPSpatialReference(
                        reference_objects=[NLPSpatialReferenceObject("door")],
                        location="front"
                    )
                ]
            ),
            "Place a flower pot in front of the house": NLPParseResult(
                "place",
                [NLPObjectToPlace("flower pot")],
                [
                    NLPSpatialReference(
                        reference_objects=[NLPSpatialReferenceObject("house")],
                        location="front",
                    )
                ]
            ),
            "Place a house": NLPParseResult(
                "place",
                [NLPObjectToPlace("house")]
            ),
            "Make a house": NLPParseResult(
                "make",
                [NLPObjectToPlace("house")]
            ),
            "Behind the house and the forest there is a ball and a pool": NLPParseResult(
                "is",
                [NLPObjectToPlace("ball"), NLPObjectToPlace("pool")],
                [
                    NLPSpatialReference(
                        reference_objects=[NLPSpatialReferenceObject("house"), NLPSpatialReferenceObject("forest")],
                        location="behind",
                    ),
                ]
            ),
            "There is a ball and a pool behind the house and the forest": NLPParseResult(
                "is",
                [NLPObjectToPlace("ball"), NLPObjectToPlace("pool")],
                [NLPSpatialReference(
                    reference_objects=[NLPSpatialReferenceObject("house"), NLPSpatialReferenceObject("forest")],
                    location="behind",
                )]
            ),
            "Place a garden behind the house": NLPParseResult(
                "place",
                [NLPObjectToPlace("garden")],
                [NLPSpatialReference(
                    reference_objects=[NLPSpatialReferenceObject("house")],
                    location="behind"
                )]
            ),
            "There is a pond in the back of the house": NLPParseResult(
                "is",
                [NLPObjectToPlace("pond")],
                [
                    NLPSpatialReference(
                        reference_objects=[NLPSpatialReferenceObject("house")],
                        location="back"
                    )
                ]
            ),
            "Add a cloud above the house": NLPParseResult(
                "add",
                [NLPObjectToPlace("cloud")],
                [
                    NLPSpatialReference(
                        reference_objects=[NLPSpatialReferenceObject("house")],
                        location="above",
                    )
                ]
            ),
            "Make another house": NLPParseResult(
                "make",
                [NLPObjectToPlace("house")],
            ),
            "Add rain below the cloud": NLPParseResult(
                "add",
                [NLPObjectToPlace("rain")],
                [
                    NLPSpatialReference(
                        reference_objects=[NLPSpatialReferenceObject("cloud")],
                        location="below",
                    )
                ]
            ),
            "Add rain under the cloud": NLPParseResult(
                "add",
                [NLPObjectToPlace("rain")],
                [
                    NLPSpatialReference(
                        reference_objects=[NLPSpatialReferenceObject("cloud")],
                        location="under",
                    )
                ]
            ),
            "Add a gnome between the houses": NLPParseResult(
                "add",
                [NLPObjectToPlace("gnome")],
                [
                    NLPSpatialReference(
                        reference_objects=[NLPSpatialReferenceObject("house", True)],
                        location="between",
                    )
                ]
            ),
            "Add a lamp on the table": NLPParseResult(
                "add",
                [NLPObjectToPlace("lamp")],
                [
                    NLPSpatialReference(
                        reference_objects=[NLPSpatialReferenceObject("table")],
                        location="on",
                    )
                ]
            ),
            "Add 50 trees and 2 balls around the house": NLPParseResult(
                "add",
                [NLPObjectToPlace("tree", count=50), NLPObjectToPlace("ball", count=2)],
                [
                    NLPSpatialReference(
                        reference_objects=[NLPSpatialReferenceObject("house")],
                        location="around",
                    )
                ]
            ),
        }

        spacy_nlp = SpaCyNLPProvider()
        for sentence, expected_result in test_sentences.items():
            with self.subTest(sentence):
                result = spacy_nlp.parse(sentence, PythonLogger())
                self.assertEqual(result, expected_result)


# endregion

# region Local mesh provider

@dataclasses.dataclass
class _LocalMesh(PlaceholderLoadableMesh):
    path: str

    def load_gltf(self, parameters: typing.Dict[str, str], logger: BroomrocketLogger) -> GLTF:
        root = parameters["root"]
        try:
            with open(self.path, 'rb') as fh:
                gltf_data = fh.read()
        except Exception as e:
            logger.error(f"Failed to read file {self.path}: {e.__str__()}")
            raise BroomrocketException(False, f"Failed to read file {self.path}: {e.__str__()}") from e
        try:
            gltf_json = json.loads(gltf_data)
        except Exception as e:
            logger.error(f"Failed to parse GLTF in {self.path}: {e.__str__()}")
            raise BroomrocketException(False, f"Failed to parse GLTF in {self.path}: {e.__str__()}") from e
        filename = os.path.basename(self.path)
        gltf = GLTF(
            {
                filename: gltf_data
            },
            filename,
            None
        )
        base_path = os.path.dirname(self.path)
        if "images" in gltf_json:
            for image in gltf_json["images"]:
                try:
                    image_path = os.path.abspath(os.path.join(base_path, urllib.parse.unquote(image["uri"])))
                except Exception as e:
                    logger.error(
                        f"Failed to resolve referenced image {image['uri']} from file {self.path}: {e.__str__()}")
                    raise BroomrocketException(
                        False,
                        f"Failed to resolve referenced image {image['uri']} from file {self.path}: {e.__str__()}"
                    ) from e
                if not image_path.startswith(root):
                    logger.error(f"{self.path} references image outside of the root directory {root}")
                    raise BroomrocketException(
                        False,
                        f"{self.path} references image outside of the root directory {root}"
                    )
                try:
                    with open(image_path, 'rb') as fh:
                        rel_path = os.path.relpath(image_path, base_path)
                        gltf.files[rel_path] = fh.read()
                except Exception as e:
                    logger.error(f"Failed to open referenced image {image['uri']} from file {self.path}: {e.__str__()}")
                    raise BroomrocketException(
                        False,
                        f"Failed to open referenced image {image['uri']} from file {self.path}: {e.__str__()}"
                    ) from e
        if "buffers" in gltf_json:
            for buffer in gltf_json["buffers"]:
                try:
                    buffers_path = os.path.abspath(os.path.join(base_path, urllib.parse.unquote(buffer["uri"])))
                except Exception as e:
                    logger.error(
                        f"Failed to resolve referenced buffer {buffer['uri']} from file {self.path}: {e.__str__()}")
                    raise BroomrocketException(
                        False,
                        f"Failed to resolve referenced buffer {buffer['uri']} from file {self.path}: {e.__str__()}"
                    ) from e
                if not buffers_path.startswith(root):
                    logger.error(f"{self.path} references buffer outside of the root directory {root}")
                    raise BroomrocketException(
                        False,
                        f"{self.path} references buffer outside of the root directory {root}"
                    )
                try:
                    with open(buffers_path, 'rb') as fh:
                        rel_path = os.path.relpath(buffers_path, base_path)
                        gltf.files[rel_path] = fh.read()
                except Exception as e:
                    logger.error(
                        f"Failed to open referenced buffer {buffer['uri']} from file {self.path}: {e.__str__()}")
                    raise BroomrocketException(
                        False,
                        f"Failed to open referenced buffer {buffer['uri']} from file {self.path}: {e.__str__()}"
                    ) from e
        return gltf


class LocalMeshProvider(MeshProvider):

    @staticmethod
    def id() -> str:
        return "local"

    @staticmethod
    def name() -> str:
        return "Local"

    def find(self, parameters: typing.Dict[str, str], term: str, logger: BroomrocketLogger) -> typing.List[LoadableMesh]:
        root = parameters["root"]
        try:
            files = list(map(lambda f: _LocalMesh(f), glob.glob(os.path.join(root, "**", "*.gltf"), recursive=True)))

            def myfilter(item: _LocalMesh) -> bool:
                words = term.split(" ")
                for word in words:
                    if word == "":
                        continue
                    if word not in os.path.basename(item.path):
                        return False
                return True

            result = list(filter(myfilter, files))
            return result
        except Exception as e:
            raise BroomrocketException(
                False,
                f"Failed to search root directory {root}: {e.__str__()}"
            ) from e


# endregion

# region Sketchfab mesh provider

@dataclasses.dataclass
class _SketchfabDownloadableMesh(PlaceholderLoadableMesh):
    """
    This mesh implementation holds a reference to a Sketchfab mesh which can be downloaded. The parameters need to
    include a Sketchfab API token in the "apikey" field.
    """
    uid: str
    name: str
    download_uri: str

    def load_gltf(self, parameters: typing.Dict[str, str], logger: BroomrocketLogger) -> GLTF:
        logger.debug(f"Sending Sketchfab download discovery request to {self.download_uri}...")
        apikey = parameters["apikey"]
        response = requests.get(self.download_uri, headers={"Authorization": f"Token {apikey}"})
        if response.status_code != 200:
            if response.status_code == 404:
                return super().load_gltf(parameters, logger)
            raise BroomrocketException(
                False,
                f"{response.status_code} status code returned from Sketchfab API for download discovery "
                f"request: {response.text}"
            )
        data = response.json()
        download_url = data["gltf"]["url"]
        logger.debug(f"Discovered GLTF download URL: {download_url}")
        response = requests.get(download_url)
        if response.status_code != 200:
            if response.status_code == 404:
                return super().load_gltf(parameters, logger)
            raise BroomrocketException(
                False,
                f"{response.status_code} status code returned from Sketchfab API for download: {response.text}"
            )

        logger.debug("Writing downloaded ZIP file to disk...")
        files: typing.Dict[str, bytes] = {}
        temp_file_name: typing.Optional[str] = None
        try:
            with tempfile.NamedTemporaryFile("w+b", delete=False) as fh:
                fh.write(response.content)
                fh.flush()
                temp_file_name = fh.name
            logger.debug(f"Extracting downloaded ZIP file {temp_file_name}...")
            with ZipFile(temp_file_name) as zip:
                for fileinfo in zip.infolist():
                    if not fileinfo.is_dir():
                        files[fileinfo.filename] = zip.read(fileinfo.filename)
        finally:
            if temp_file_name is not None:
                os.unlink(temp_file_name)
        logger.debug(f"Files in ZIP: {files.keys()}")
        return GLTF(
            files,
            "scene.gltf",
            "license.txt"
        )


@dataclasses.dataclass
class _SketchfabLicense:
    """
    This class holds a reference to a Sketchfab license description.
    """
    label: str
    fullName: str
    requirements: str
    slug: str


class SketchfabMeshProvider(MeshProvider):
    """
    This mesh provider works against the Sketchfab API. It requires an API key for downloading meshes.
    """

    endpoint: str = 'https://api.Sketchfab.com/v3'
    _license_cache: typing.List[_SketchfabLicense]

    def __init__(self):
        self._license_cache = []

    @staticmethod
    def id() -> str:
        return "Sketchfab"

    @staticmethod
    def name() -> str:
        return "Sketchfab"

    def licenses(self) -> typing.List[License]:
        if self._license_cache is None or len(self._license_cache) == 0:
            url = f"{self.endpoint}/licenses"
            response = requests.get(url)
            self._license_cache = list(map(lambda data: _SketchfabLicense(
                data["label"],
                data["fullName"],
                data["requirements"],
                data["slug"]
            ), response.json()["results"]))
        return list(map(
            lambda license: License(license.slug, license.label, license.requirements),
            self._license_cache
        ))

    def find(
            self,
            parameters: typing.Dict[str, str],
            term: str,
            logger: BroomrocketLogger
    ) -> typing.List[LoadableMesh]:
        apikey = parameters["apikey"]
        url = f"{self.endpoint}/search?type=models&downloadable=true&q={urllib.parse.quote(term)}"
        if "license" in parameters:
            url += f"&license={urllib.parse.quote(parameters['license'])}"
        logger.debug(f"Sending Sketchfab request to {url}...")
        response = requests.get(url, headers={"Authorization": f"Token {apikey}"})
        if response.status_code != 200:
            raise BroomrocketException(
                False,
                f"Incorrect response from Sketchfab API ({response.status_code}): {response.text}"
            )
        data = response.json()
        if len(data["results"]) == 0:
            logger.info("No mesh matching the criteria found, using placeholder.")
            return [PlaceholderLoadableMesh()]
        return list(map(lambda mesh: _SketchfabDownloadableMesh(
            mesh["uid"],
            mesh["name"],
            f"{self.endpoint}/models/{urllib.parse.quote(mesh['uid'])}/download"
        ), data["results"]))


# endregion

# region Dummy mesh provider

class DummyMeshProvider(MeshProvider):
    """
    This mesh provider returns a 2x2x2m cube.
    """

    @staticmethod
    def id() -> str:
        return "dummy"

    @staticmethod
    def name() -> str:
        return "Dummy"

    def find(
            self,
            parameters: typing.Dict[str, str],
            term: str,
            logger: BroomrocketLogger
    ) -> typing.List[LoadableMesh]:
        return [PlaceholderLoadableMesh()]


# endregion

# region Broomrocket core

class BroomrocketException(Exception):
    """
    This exception holds an error message presentable to the user. It also includes a flag that indicates if changes
    have been made to the 3D scene.
    """

    def __init__(self, changes: bool, msg: str):
        self._changes = changes
        self._msg = msg

    def changes(self) -> bool:
        return self._changes

    def __str__(self):
        return self._msg


class Broomrocket:
    """
    This is the main class of the Broomrocket workflow. It is called by the Blender operators below.
    """

    def __init__(
            self,
            engine: Engine,
            mesh_providers: typing.List[MeshProvider],
            nlp: NLPProvider,
            reference_finders: typing.List[ReferenceFinder],
            placement_strategies: typing.List[PlacementStrategy]
    ):
        self._engine = engine
        self._mesh_providers = mesh_providers
        self._nlp = nlp
        self._reference_finders = reference_finders
        self._placement_strategies = placement_strategies

    def mesh_providers(self) -> typing.Dict[str, str]:
        result = {}
        for mesh_provider in self._mesh_providers:
            result[mesh_provider.id()] = mesh_provider.name()
        return result

    def run(
            self,
            mesh_provider_id: str,
            mesh_provider_parameters: typing.Dict[str, str],
            sentence: str,
            logger: BroomrocketLogger,
    ) -> str:
        """
        This method processes the given sentence by analyzing them and downloading meshes from the given mesh provider.
        It returns a text with any license information it has about the downloaded meshes.
        """
        nlp_results = self._nlp.parse(sentence, logger)
        logger.debug(str(nlp_results))
        changes = False

        license_info = ""

        mesh_providers = list(filter(lambda mp: mp.id() == mesh_provider_id, self._mesh_providers))
        if len(mesh_providers) != 1:
            raise BroomrocketException(False, f"Bug: incorrect mesh provider ID: {mesh_provider_id}")
        mesh_provider = mesh_providers[0]

        objects = []
        for object in nlp_results.objects:
            try:
                meshes = mesh_provider.find(mesh_provider_parameters, object.object, logger)
                if len(meshes) == 0:
                    meshes = [PlaceholderLoadableMesh()]
            except Exception as e:
                raise BroomrocketException(changes, f"Failed to search for {object} ({e.__str__()}") from e
            try:
                gltf_data = meshes[0].load_gltf(mesh_provider_parameters, logger)
                if gltf_data.license_file is not None:
                    license_info += gltf_data.files[gltf_data.license_file].decode('utf-8').strip() + "\n\n"
            except Exception as e:
                raise BroomrocketException(changes, f"Failed to download mesh for {object} ({e.__str__()})") from e
            changes = True
            if object.count == 1:
                loaded_mesh = self._engine.load_gltf(object.object, gltf_data, logger)
                objects.append(loaded_mesh)
            else:
                for i in range(1, object.count + 1):
                    objects.append(self._engine.load_gltf(f"{object.object}.{i}", gltf_data, logger))

        if len(objects) == 0:
            raise BroomrocketException(changes, "No objects to place")

        all_objects = self._engine.list_objects()
        volumes = []
        minmaxes = []
        orientation = None
        # Apply placement strategies to get all volumes. These volumes will be intersected later to provide a minimum
        # volume to place the objects into.
        logger.debug(f"Processing {len(nlp_results.spatial_references)} spatial references...")
        for reference in nlp_results.spatial_references:
            reference_meshes = all_objects
            for reference_finder in self._reference_finders:
                reference_meshes = reference_finder.find_reference_objects(
                    reference.reference_objects,
                    reference_meshes
                )
            if len(reference_meshes) == 0:
                raise BroomrocketException(
                    changes,
                    f"Referenced objects {reference.reference_objects} not found."
                    f" Please rephrase your query."
                )
            spatial_reference = SpatialReference(reference_meshes, reference.distance, reference.units)
            found_placement_strategy = False
            for placement_strategy in self._placement_strategies:
                if (reference.location is None and placement_strategy.keywords is None) or \
                        (
                                placement_strategy.keywords is not None and reference.location.lower() in placement_strategy.keywords):
                    found_placement_strategy = True
                    logger.debug(f"Using the '{placement_strategy.name}' placement strategy...")
                    placement_volume, placement_preference = placement_strategy.calculate_placement_volume(
                        objects,
                        spatial_reference,
                        all_objects,
                        logger
                    )
                    volumes.append(placement_volume)
                    for minmax in placement_preference.axis_minmax:
                        minmaxes.append(minmax)
                    if orientation is not None and \
                            placement_preference.orientation is not None and \
                            orientation != placement_preference.orientation:
                        raise BroomrocketException(
                            changes,
                            "Bug: conflicting orientation results!"
                        )
                    orientation = placement_preference.orientation
            if not found_placement_strategy:
                raise BroomrocketException(
                    changes,
                    f"Cannot find placement strategy for keyword {reference.location}."
                    f" Please rephrase your query."
                )
        if len(nlp_results.spatial_references) == 0:
            # Special case: we have no spacial reference, we need to place it somewhere close to the origin
            orientation = Orientation.Y
            size_x = 0
            size_y = 0
            size_z = 0
            for object in objects:
                size_y += object.size_y
                size_x = max(size_x, object.size_x)
                size_z = max(size_z, object.size_z)
            volumes.append(Volume(
                -size_x / 2,
                size_x / 2,
                -size_y / 2,
                size_y / 2,
                0,
                size_z
            ))
        # Reconcile volumes
        volume = Volume(
            float("-inf"),
            float("inf"),
            float("-inf"),
            float("inf"),
            float("-inf"),
            float("inf"),
        )

        for v in volumes:
            volume = volume.intersect(v)
            if volume is None:
                raise BroomrocketException(
                    changes,
                    f"Cannot find a proper placement location for meshes. Possibly conflicting spatial descriptions "
                    f"or not enough space?"
                )
        logger.debug(
            f"Placing mesh between ({volume.min_x}, {volume.min_y}, {volume.min_z}) and "
            f"({volume.max_x}, {volume.max_y}, {volume.max_z})"
        )
        # Determine if we have enough space in each direction:
        if orientation is None:
            orientation = Orientation.Y
        size_y = 0
        size_x = 0
        size_z = 0
        if orientation == Orientation.Y:
            for obj in objects:
                size_y = obj.size_y
                if obj.size_x > size_x:
                    size_x = obj.size_x
                if obj.size_z > size_z:
                    size_z = obj.size_z
        else:
            for obj in objects:
                size_x = obj.size_x
                if obj.size_y > size_y:
                    size_y = obj.size_y
                if obj.size_z > size_z:
                    size_z = obj.size_z

        if size_x > volume.size_x * 1.001 or size_y > volume.size_y * 1.001 or size_z > volume.size_z * 1.001:
            logger.error(
                f"Volume {volume.size_z}/{volume.size_y}/{volume.size_z} is smaller than the required size of {size_x}/{size_y}/{size_z}"
            )
            raise BroomrocketException(
                changes,
                "Not enough space to place meshes!"
            )

        starting_positions = {
            Axis.X: None,
            Axis.Y: None,
            Axis.Z: None
        }
        directions = {
            Axis.X: None,
            Axis.Y: None,
            Axis.Z: None
        }
        for axis in [Axis.X, Axis.Y, Axis.Z]:
            for minmax in minmaxes:
                if minmax[0] == axis:
                    if minmax[1] == MinMax.MIN:
                        starting_positions[axis] = getattr(volume, "min_" + str(axis))
                        directions[axis] = 1
                    else:
                        starting_positions[axis] = getattr(volume, "max_" + str(axis))
                        directions[axis] = -1
                    break

        # Place the objects
        for axis in [Axis.X, Axis.Y, Axis.Z]:
            if axis == orientation.get_axis():
                if starting_positions[axis] is None:
                    # Distribute the objects along this axis equally
                    logger.debug(f"Distributing objects along the {axis} equally.")
                    segment_size = volume.size_axis(axis) / len(objects)
                    offset = 0
                    starting_point = volume.min_axis(axis)
                    for object in objects:
                        offsets = object.offsets_axis(axis)
                        spacing = object.size.size_axis(axis)
                        extra = segment_size - spacing
                        object.translation.set_axis(
                            axis,
                            starting_point + offset + extra / 2 + (-1 * offsets[0])
                        )
                        offset += segment_size
                else:
                    # Place the objects as close to the starting/ending position as possible
                    logger.debug(f"Placing objects along the {axis} at one end.")
                    if directions[axis] == -1:
                        # Move to the end
                        total_size = 0
                        for object in objects:
                            total_size += object.size.size_axis(axis)
                        start_pos = volume.max_axis(axis) - total_size
                    else:
                        start_pos = volume.min_axis(axis)
                    offset = 0
                    for object in objects:
                        offsets = object.offsets_axis(axis)
                        logger.info(f"{offsets[0]}")
                        object.translation.set_axis(
                            axis,
                            start_pos + offset + (-1 * offsets[0])
                        )
                        offset += object.size.size_axis(axis)
            else:
                if starting_positions[axis] is None:
                    if axis == Axis.Z:
                        # Place objects at the bottom
                        logger.debug(f"Placing objects at the bottom of the target volume on the z axis.")
                        for object in objects:
                            offsets = object.offsets_z
                            object.translation.set_axis(axis, volume.min_z + (-1 * offsets[0]))
                    else:
                        # Place the objects in the middle of the volume
                        logger.debug(f"Placing objects at the middle of the target volume on the {axis} axis.")
                        vol_min = volume.min_axis(axis)
                        vol_max = volume.max_axis(axis)
                        vol_middle = vol_min + (vol_max - vol_min) / 2
                        for object in objects:
                            object.translation.set_axis(axis, vol_middle)
                else:
                    # Place the objects according to the preference
                    logger.debug(f"Placing objects according to the placement strategy on the {axis} axis.")
                    for object in objects:
                        offsets = object.offsets_axis(axis)
                        if directions[axis] == -1:
                            object.translation.set_axis(axis, volume.max_axis(axis) - offsets[1])
                        else:
                            object.translation.set_axis(axis, volume.min_axis(axis) + (-1 * offsets[0]))
        return license_info

# endregion
